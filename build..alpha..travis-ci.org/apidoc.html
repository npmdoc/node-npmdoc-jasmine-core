<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://jasmine.github.io"

    >jasmine-core (v2.5.2)</a>
</h1>
<h4>Official packaging of Jasmine's core files for use by Node.js projects.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jasmine-core">module jasmine-core</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.Any">
            function <span class="apidocSignatureSpan">jasmine-core.</span>Any
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.Anything">
            function <span class="apidocSignatureSpan">jasmine-core.</span>Anything
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.ArrayContaining">
            function <span class="apidocSignatureSpan">jasmine-core.</span>ArrayContaining
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.CallTracker">
            function <span class="apidocSignatureSpan">jasmine-core.</span>CallTracker
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.Clock">
            function <span class="apidocSignatureSpan">jasmine-core.</span>Clock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.DelayedFunctionScheduler">
            function <span class="apidocSignatureSpan">jasmine-core.</span>DelayedFunctionScheduler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.Env">
            function <span class="apidocSignatureSpan">jasmine-core.</span>Env
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.ExceptionFormatter">
            function <span class="apidocSignatureSpan">jasmine-core.</span>ExceptionFormatter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.Expectation">
            function <span class="apidocSignatureSpan">jasmine-core.</span>Expectation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.JsApiReporter">
            function <span class="apidocSignatureSpan">jasmine-core.</span>JsApiReporter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.MockDate">
            function <span class="apidocSignatureSpan">jasmine-core.</span>MockDate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.ObjectContaining">
            function <span class="apidocSignatureSpan">jasmine-core.</span>ObjectContaining
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.Order">
            function <span class="apidocSignatureSpan">jasmine-core.</span>Order
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.QueueRunner">
            function <span class="apidocSignatureSpan">jasmine-core.</span>QueueRunner
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.ReportDispatcher">
            function <span class="apidocSignatureSpan">jasmine-core.</span>ReportDispatcher
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.Spec">
            function <span class="apidocSignatureSpan">jasmine-core.</span>Spec
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.SpyRegistry">
            function <span class="apidocSignatureSpan">jasmine-core.</span>SpyRegistry
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.SpyStrategy">
            function <span class="apidocSignatureSpan">jasmine-core.</span>SpyStrategy
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.StringMatching">
            function <span class="apidocSignatureSpan">jasmine-core.</span>StringMatching
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.Suite">
            function <span class="apidocSignatureSpan">jasmine-core.</span>Suite
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.Timer">
            function <span class="apidocSignatureSpan">jasmine-core.</span>Timer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.TreeProcessor">
            function <span class="apidocSignatureSpan">jasmine-core.</span>TreeProcessor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.base">
            function <span class="apidocSignatureSpan">jasmine-core.</span>base
            <span class="apidocSignatureSpan">(j$, jasmineGlobal)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.boot">
            function <span class="apidocSignatureSpan">jasmine-core.</span>boot
            <span class="apidocSignatureSpan">(jasmineRequire)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.buildExpectationResult">
            function <span class="apidocSignatureSpan">jasmine-core.</span>buildExpectationResult
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.core">
            function <span class="apidocSignatureSpan">jasmine-core.</span>core
            <span class="apidocSignatureSpan">(jRequire)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.errors">
            function <span class="apidocSignatureSpan">jasmine-core.</span>errors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.formatErrorMsg">
            function <span class="apidocSignatureSpan">jasmine-core.</span>formatErrorMsg
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.interface">
            function <span class="apidocSignatureSpan">jasmine-core.</span>interface
            <span class="apidocSignatureSpan">(jasmine, env)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.matchersUtil">
            function <span class="apidocSignatureSpan">jasmine-core.</span>matchersUtil
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.pp">
            function <span class="apidocSignatureSpan">jasmine-core.</span>pp
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.requireMatchers">
            function <span class="apidocSignatureSpan">jasmine-core.</span>requireMatchers
            <span class="apidocSignatureSpan">(jRequire, j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.toBe">
            function <span class="apidocSignatureSpan">jasmine-core.</span>toBe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.toBeCloseTo">
            function <span class="apidocSignatureSpan">jasmine-core.</span>toBeCloseTo
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.toBeDefined">
            function <span class="apidocSignatureSpan">jasmine-core.</span>toBeDefined
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.toBeFalsy">
            function <span class="apidocSignatureSpan">jasmine-core.</span>toBeFalsy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.toBeGreaterThan">
            function <span class="apidocSignatureSpan">jasmine-core.</span>toBeGreaterThan
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.toBeGreaterThanOrEqual">
            function <span class="apidocSignatureSpan">jasmine-core.</span>toBeGreaterThanOrEqual
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.toBeLessThan">
            function <span class="apidocSignatureSpan">jasmine-core.</span>toBeLessThan
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.toBeLessThanOrEqual">
            function <span class="apidocSignatureSpan">jasmine-core.</span>toBeLessThanOrEqual
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.toBeNaN">
            function <span class="apidocSignatureSpan">jasmine-core.</span>toBeNaN
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.toBeNull">
            function <span class="apidocSignatureSpan">jasmine-core.</span>toBeNull
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.toBeTruthy">
            function <span class="apidocSignatureSpan">jasmine-core.</span>toBeTruthy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.toBeUndefined">
            function <span class="apidocSignatureSpan">jasmine-core.</span>toBeUndefined
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.toContain">
            function <span class="apidocSignatureSpan">jasmine-core.</span>toContain
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.toEqual">
            function <span class="apidocSignatureSpan">jasmine-core.</span>toEqual
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.toHaveBeenCalled">
            function <span class="apidocSignatureSpan">jasmine-core.</span>toHaveBeenCalled
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.toHaveBeenCalledTimes">
            function <span class="apidocSignatureSpan">jasmine-core.</span>toHaveBeenCalledTimes
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.toHaveBeenCalledWith">
            function <span class="apidocSignatureSpan">jasmine-core.</span>toHaveBeenCalledWith
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.toMatch">
            function <span class="apidocSignatureSpan">jasmine-core.</span>toMatch
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.toThrow">
            function <span class="apidocSignatureSpan">jasmine-core.</span>toThrow
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.toThrowError">
            function <span class="apidocSignatureSpan">jasmine-core.</span>toThrowError
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.util">
            function <span class="apidocSignatureSpan">jasmine-core.</span>util
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.version">
            function <span class="apidocSignatureSpan">jasmine-core.</span>version
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jasmine-core.</span>console</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jasmine-core.</span>files</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jasmine-core.</span>jasmine</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jasmine-core.console">module jasmine-core.console</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.console.console">
            function <span class="apidocSignatureSpan">jasmine-core.</span>console
            <span class="apidocSignatureSpan">(jRequire, j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.console.ConsoleReporter">
            function <span class="apidocSignatureSpan">jasmine-core.console.</span>ConsoleReporter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jasmine-core.jasmine">module jasmine-core.jasmine</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.Any">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>Any
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.Anything">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>Anything
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.ArrayContaining">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>ArrayContaining
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.CallTracker">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>CallTracker
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.Clock">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>Clock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.DelayedFunctionScheduler">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>DelayedFunctionScheduler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.Env">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>Env
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.ExceptionFormatter">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>ExceptionFormatter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.Expectation">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>Expectation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.JsApiReporter">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>JsApiReporter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.MockDate">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>MockDate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.ObjectContaining">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>ObjectContaining
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.Order">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>Order
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.QueueRunner">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>QueueRunner
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.ReportDispatcher">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>ReportDispatcher
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.Spec">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>Spec
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.SpyRegistry">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>SpyRegistry
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.SpyStrategy">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>SpyStrategy
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.StringMatching">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>StringMatching
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.Suite">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>Suite
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.Timer">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>Timer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.TreeProcessor">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>TreeProcessor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.base">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>base
            <span class="apidocSignatureSpan">(j$, jasmineGlobal)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.boot">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>boot
            <span class="apidocSignatureSpan">(jasmineRequire)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.buildExpectationResult">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>buildExpectationResult
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.core">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>core
            <span class="apidocSignatureSpan">(jRequire)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.errors">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>errors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.formatErrorMsg">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>formatErrorMsg
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.interface">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>interface
            <span class="apidocSignatureSpan">(jasmine, env)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.matchersUtil">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>matchersUtil
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.pp">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>pp
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.requireMatchers">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>requireMatchers
            <span class="apidocSignatureSpan">(jRequire, j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.toBe">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.toBeCloseTo">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBeCloseTo
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.toBeDefined">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBeDefined
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.toBeFalsy">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBeFalsy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.toBeGreaterThan">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBeGreaterThan
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.toBeGreaterThanOrEqual">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBeGreaterThanOrEqual
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.toBeLessThan">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBeLessThan
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.toBeLessThanOrEqual">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBeLessThanOrEqual
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.toBeNaN">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBeNaN
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.toBeNull">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBeNull
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.toBeTruthy">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBeTruthy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.toBeUndefined">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBeUndefined
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.toContain">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toContain
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.toEqual">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toEqual
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.toHaveBeenCalled">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toHaveBeenCalled
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.toHaveBeenCalledTimes">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toHaveBeenCalledTimes
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.toHaveBeenCalledWith">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toHaveBeenCalledWith
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.toMatch">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toMatch
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.toThrow">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toThrow
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.toThrowError">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toThrowError
            <span class="apidocSignatureSpan">(j$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.util">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>util
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jasmine-core.jasmine.version">
            function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>version
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>files</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jasmine-core" id="apidoc.module.jasmine-core">module jasmine-core</a></h1>


    <h2>
        <a href="#apidoc.element.jasmine-core.Any" id="apidoc.element.jasmine-core.Any">
        function <span class="apidocSignatureSpan">jasmine-core.</span>Any
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Any = function (j$) {

  function Any(expectedObject) {
    if (typeof expectedObject === &#x27;undefined&#x27;) {
      throw new TypeError(
        &#x27;jasmine.any() expects to be passed a constructor function. &#x27; +
        &#x27;Please pass one or use jasmine.anything() to match any object.&#x27;
      );
    }
    this.expectedObject = expectedObject;
  }

  Any.prototype.asymmetricMatch = function(other) {
    if (this.expectedObject == String) {
      return typeof other == &#x27;string&#x27; || other instanceof String;
    }

    if (this.expectedObject == Number) {
      return typeof other == &#x27;number&#x27; || other instanceof Number;
    }

    if (this.expectedObject == Function) {
      return typeof other == &#x27;function&#x27; || other instanceof Function;
    }

    if (this.expectedObject == Object) {
      return typeof other == &#x27;object&#x27;;
    }

    if (this.expectedObject == Boolean) {
      return typeof other == &#x27;boolean&#x27;;
    }

    return other instanceof this.expectedObject;
  };

  Any.prototype.jasmineToString = function() {
    return &#x27;&#x3c;jasmine.any(&#x27; + j$.fnNameFor(this.expectedObject) + &#x27;)&#x3e;&#x27;;
  };

  return Any;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  getJasmineRequire().core = function(jRequire) {
var j$ = {};

jRequire.base(j$, jasmineGlobal);
j$.util = jRequire.util();
j$.errors = jRequire.errors();
j$.formatErrorMsg = jRequire.formatErrorMsg();
j$.Any = jRequire.<span class="apidocCodeKeywordSpan">Any</span>(j$);
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.Anything" id="apidoc.element.jasmine-core.Anything">
        function <span class="apidocSignatureSpan">jasmine-core.</span>Anything
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Anything = function (j$) {

  function Anything() {}

  Anything.prototype.asymmetricMatch = function(other) {
    return !j$.util.isUndefined(other) &#x26;&#x26; other !== null;
  };

  Anything.prototype.jasmineToString = function() {
    return &#x27;&#x3c;jasmine.anything&#x3e;&#x27;;
  };

  return Anything;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var j$ = {};

jRequire.base(j$, jasmineGlobal);
j$.util = jRequire.util();
j$.errors = jRequire.errors();
j$.formatErrorMsg = jRequire.formatErrorMsg();
j$.Any = jRequire.Any(j$);
j$.Anything = jRequire.<span class="apidocCodeKeywordSpan">Anything</span>(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.ArrayContaining" id="apidoc.element.jasmine-core.ArrayContaining">
        function <span class="apidocSignatureSpan">jasmine-core.</span>ArrayContaining
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ArrayContaining = function (j$) {
  function ArrayContaining(sample) {
    this.sample = sample;
  }

  ArrayContaining.prototype.asymmetricMatch = function(other) {
    var className = Object.prototype.toString.call(this.sample);
    if (className !== &#x27;[object Array]&#x27;) { throw new Error(&#x27;You must provide an array to arrayContaining, not \&#x27;&#x27; + this.sample + &#x27;\&#x27;.&#x27;); }

    for (var i = 0; i &#x3c; this.sample.length; i++) {
      var item = this.sample[i];
      if (!j$.matchersUtil.contains(other, item)) {
        return false;
      }
    }

    return true;
  };

  ArrayContaining.prototype.jasmineToString = function () {
    return &#x27;&#x3c;jasmine.arrayContaining(&#x27; + jasmine.pp(this.sample) +&#x27;)&#x3e;&#x27;;
  };

  return ArrayContaining;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.<span class="apidocCodeKeywordSpan">ArrayContaining</span>(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.Spec(j$);
j$.SpyRegistry = jRequire.SpyRegistry(j$);
j$.SpyStrategy = jRequire.SpyStrategy(j$);
j$.StringMatching = jRequire.StringMatching(j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.CallTracker" id="apidoc.element.jasmine-core.CallTracker">
        function <span class="apidocSignatureSpan">jasmine-core.</span>CallTracker
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CallTracker = function (j$) {

  function CallTracker() {
    var calls = [];
    var opts = {};

    function argCloner(context) {
      var clonedArgs = [];
      var argsAsArray = j$.util.argsToArray(context.args);
      for(var i = 0; i &#x3c; argsAsArray.length; i++) {
        if(Object.prototype.toString.apply(argsAsArray[i]).match(/^\[object/)) {
          clonedArgs.push(j$.util.clone(argsAsArray[i]));
        } else {
          clonedArgs.push(argsAsArray[i]);
        }
      }
      context.args = clonedArgs;
    }

    this.track = function(context) {
      if(opts.cloneArgs) {
        argCloner(context);
      }
      calls.push(context);
    };

    this.any = function() {
      return !!calls.length;
    };

    this.count = function() {
      return calls.length;
    };

    this.argsFor = function(index) {
      var call = calls[index];
      return call ? call.args : [];
    };

    this.all = function() {
      return calls;
    };

    this.allArgs = function() {
      var callArgs = [];
      for(var i = 0; i &#x3c; calls.length; i++){
        callArgs.push(calls[i].args);
      }

      return callArgs;
    };

    this.first = function() {
      return calls[0];
    };

    this.mostRecent = function() {
      return calls[calls.length - 1];
    };

    this.reset = function() {
      calls = [];
    };

    this.saveArgumentsByValue = function() {
      opts.cloneArgs = true;
    };

  }

  return CallTracker;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

jRequire.base(j$, jasmineGlobal);
j$.util = jRequire.util();
j$.errors = jRequire.errors();
j$.formatErrorMsg = jRequire.formatErrorMsg();
j$.Any = jRequire.Any(j$);
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.<span class="apidocCodeKeywordSpan">CallTracker</span>(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.Clock" id="apidoc.element.jasmine-core.Clock">
        function <span class="apidocSignatureSpan">jasmine-core.</span>Clock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Clock = function () {
  function Clock(global, delayedFunctionSchedulerFactory, mockDate) {
    var self = this,
      realTimingFunctions = {
        setTimeout: global.setTimeout,
        clearTimeout: global.clearTimeout,
        setInterval: global.setInterval,
        clearInterval: global.clearInterval
      },
      fakeTimingFunctions = {
        setTimeout: setTimeout,
        clearTimeout: clearTimeout,
        setInterval: setInterval,
        clearInterval: clearInterval
      },
      installed = false,
      delayedFunctionScheduler,
      timer;


    self.install = function() {
      if(!originalTimingFunctionsIntact()) {
        throw new Error(&#x27;Jasmine Clock was unable to install over custom global timer functions. Is the clock already installed?&#x27;);
      }
      replace(global, fakeTimingFunctions);
      timer = fakeTimingFunctions;
      delayedFunctionScheduler = delayedFunctionSchedulerFactory();
      installed = true;

      return self;
    };

    self.uninstall = function() {
      delayedFunctionScheduler = null;
      mockDate.uninstall();
      replace(global, realTimingFunctions);

      timer = realTimingFunctions;
      installed = false;
    };

    self.withMock = function(closure) {
      this.install();
      try {
        closure();
      } finally {
        this.uninstall();
      }
    };

    self.mockDate = function(initialDate) {
      mockDate.install(initialDate);
    };

    self.setTimeout = function(fn, delay, params) {
      if (legacyIE()) {
        if (arguments.length &#x3e; 2) {
          throw new Error(&#x27;IE &#x3c; 9 cannot support extra params to setTimeout without a polyfill&#x27;);
        }
        return timer.setTimeout(fn, delay);
      }
      return Function.prototype.apply.apply(timer.setTimeout, [global, arguments]);
    };

    self.setInterval = function(fn, delay, params) {
      if (legacyIE()) {
        if (arguments.length &#x3e; 2) {
          throw new Error(&#x27;IE &#x3c; 9 cannot support extra params to setInterval without a polyfill&#x27;);
        }
        return timer.setInterval(fn, delay);
      }
      return Function.prototype.apply.apply(timer.setInterval, [global, arguments]);
    };

    self.clearTimeout = function(id) {
      return Function.prototype.call.apply(timer.clearTimeout, [global, id]);
    };

    self.clearInterval = function(id) {
      return Function.prototype.call.apply(timer.clearInterval, [global, id]);
    };

    self.tick = function(millis) {
      if (installed) {
        delayedFunctionScheduler.tick(millis, function(millis) { mockDate.tick(millis); });
      } else {
        throw new Error(&#x27;Mock clock is not installed, use jasmine.clock().install()&#x27;);
      }
    };

    return self;

    function originalTimingFunctionsIntact() {
      return global.setTimeout === realTimingFunctions.setTimeout &#x26;&#x26;
        global.clearTimeout === realTimingFunctions.clearTimeout &#x26;&#x26;
        global.setInterval === realTimingFunctions.setInterval &#x26;&#x26;
        global.clearInterval === realTimingFunctions.clearInterval;
    }

    function legacyIE() {
      //if these methods are polyfilled, apply will be present
      return !(realTimingFunctions.setTimeout || realTimingFunctions.setInterval).apply;
    }

    function replace(dest, source) {
      for (var prop in source) {
        dest[prop] = source[prop];
      }
    }

    function setTimeout(fn, delay) {
      return delayedFunctionScheduler.scheduleFunction(fn, delay, argSlice(arguments, 2));
    }

    function clearTimeout(id) {
      return delayedFunctionScheduler.removeFunctionWithId(id);
    }

    function setInterval(fn, interval) {
      return delayedFunctionScheduler.scheduleFunction(fn, interval, argSlice(arguments, 2), true);
    }

    function clearInterval(id) {
      return delayedFunctionScheduler.removeFunctionWithId(id);
    }

    function argSlice(argsObj, n) {
      return Array.prototype.slice.call(argsObj, n);
    }
  }

  return Clock;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.util = jRequire.util();
j$.errors = jRequire.errors();
j$.formatErrorMsg = jRequire.formatErrorMsg();
j$.Any = jRequire.Any(j$);
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.<span class="apidocCodeKeywordSpan">Clock</span>();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.DelayedFunctionScheduler" id="apidoc.element.jasmine-core.DelayedFunctionScheduler">
        function <span class="apidocSignatureSpan">jasmine-core.</span>DelayedFunctionScheduler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DelayedFunctionScheduler = function () {
  function DelayedFunctionScheduler() {
    var self = this;
    var scheduledLookup = [];
    var scheduledFunctions = {};
    var currentTime = 0;
    var delayedFnCount = 0;

    self.tick = function(millis, tickDate) {
      millis = millis || 0;
      var endTime = currentTime + millis;

      runScheduledFunctions(endTime, tickDate);
      currentTime = endTime;
    };

    self.scheduleFunction = function(funcToCall, millis, params, recurring, timeoutKey, runAtMillis) {
      var f;
      if (typeof(funcToCall) === &#x27;string&#x27;) {
<span class="apidocCodeCommentSpan">        /* jshint evil: true */
</span>        f = function() { return eval(funcToCall); };
        /* jshint evil: false */
      } else {
        f = funcToCall;
      }

      millis = millis || 0;
      timeoutKey = timeoutKey || ++delayedFnCount;
      runAtMillis = runAtMillis || (currentTime + millis);

      var funcToSchedule = {
        runAtMillis: runAtMillis,
        funcToCall: f,
        recurring: recurring,
        params: params,
        timeoutKey: timeoutKey,
        millis: millis
      };

      if (runAtMillis in scheduledFunctions) {
        scheduledFunctions[runAtMillis].push(funcToSchedule);
      } else {
        scheduledFunctions[runAtMillis] = [funcToSchedule];
        scheduledLookup.push(runAtMillis);
        scheduledLookup.sort(function (a, b) {
          return a - b;
        });
      }

      return timeoutKey;
    };

    self.removeFunctionWithId = function(timeoutKey) {
      for (var runAtMillis in scheduledFunctions) {
        var funcs = scheduledFunctions[runAtMillis];
        var i = indexOfFirstToPass(funcs, function (func) {
          return func.timeoutKey === timeoutKey;
        });

        if (i &#x3e; -1) {
          if (funcs.length === 1) {
            delete scheduledFunctions[runAtMillis];
            deleteFromLookup(runAtMillis);
          } else {
            funcs.splice(i, 1);
          }

          // intervals get rescheduled when executed, so there&#x27;s never more
          // than a single scheduled function with a given timeoutKey
          break;
        }
      }
    };

    return self;

    function indexOfFirstToPass(array, testFn) {
      var index = -1;

      for (var i = 0; i &#x3c; array.length; ++i) {
        if (testFn(array[i])) {
          index = i;
          break;
        }
      }

      return index;
    }

    function deleteFromLookup(key) {
      var value = Number(key);
      var i = indexOfFirstToPass(scheduledLookup, function (millis) {
        return millis === value;
      });

      if (i &#x3e; -1) {
        scheduledLookup.splice(i, 1);
      }
    }

    function reschedule(scheduledFn) {
      self.scheduleFunction(scheduledFn.funcToCall,
        scheduledFn.millis,
        scheduledFn.params,
        true,
        scheduledFn.timeoutKey,
        scheduledFn.runAtMillis + scheduledFn.millis);
    }

    function forEachFunction(funcsToRun, callback) {
      for (var i = 0; i &#x3c; funcsToRun.length; ++i) {
        callback(funcsToRun[i]);
      }
    }

    function runScheduledFunctions(endTime, tickDate) {
      tickDate = tickDate || function() {};
      if (scheduledLookup.length === 0 || scheduledLookup[0] &#x3e; endTime) {
        tickDate(endTime - currentTime);
        return;
      }

      do {
        var newCurrentTime = scheduledLookup.shift();
        tickDate(newCurrentTime - currentTime);

        currentTime = newCurrentTime;

        var funcsToRun = scheduledFunctions[currentTime];
        delete scheduledFunctions[currentTime];

        forEachFunction(funcsToRun, function(funcToRun) {
          if (funcToRun.recurring) {
            reschedule(funcToRun);
          }
        });

        forEachFunction(funcsToRun, function(funcToRun) {
          funcToRun.funcToCall.apply(null, funcToRun.params || []);
        });
      } while (scheduledLookup.length &#x3e; 0 &#x26;&#x26;
              // checking first if we&#x27;re out of time prevents setTimeout(0)
              // scheduled in a funcToRun from forcing an extra iteration
                 currentTime !== endTime  &#x26;&#x26;
                 scheduledLookup[0] &#x3c;= endT ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.errors = jRequire.errors();
j$.formatErrorMsg = jRequire.formatErrorMsg();
j$.Any = jRequire.Any(j$);
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.<span class="apidocCodeKeywordSpan">DelayedFunctionScheduler</span>();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.Env" id="apidoc.element.jasmine-core.Env">
        function <span class="apidocSignatureSpan">jasmine-core.</span>Env
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Env = function (j$) {
  function Env(options) {
    options = options || {};

    var self = this;
    var global = options.global || j$.getGlobal();

    var totalSpecsDefined = 0;

    var catchExceptions = true;

    var realSetTimeout = j$.getGlobal().setTimeout;
    var realClearTimeout = j$.getGlobal().clearTimeout;
    this.clock = new j$.Clock(global, function () { return new j$.DelayedFunctionScheduler(); }, new j$.MockDate(global));

    var runnableResources = {};

    var currentSpec = null;
    var currentlyExecutingSuites = [];
    var currentDeclarationSuite = null;
    var throwOnExpectationFailure = false;
    var random = false;
    var seed = null;

    var currentSuite = function() {
      return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];
    };

    var currentRunnable = function() {
      return currentSpec || currentSuite();
    };

    var reporter = new j$.ReportDispatcher([
      &#x27;jasmineStarted&#x27;,
      &#x27;jasmineDone&#x27;,
      &#x27;suiteStarted&#x27;,
      &#x27;suiteDone&#x27;,
      &#x27;specStarted&#x27;,
      &#x27;specDone&#x27;
    ]);

    this.specFilter = function() {
      return true;
    };

    this.addCustomEqualityTester = function(tester) {
      if(!currentRunnable()) {
        throw new Error(&#x27;Custom Equalities must be added in a before function or a spec&#x27;);
      }
      runnableResources[currentRunnable().id].customEqualityTesters.push(tester);
    };

    this.addMatchers = function(matchersToAdd) {
      if(!currentRunnable()) {
        throw new Error(&#x27;Matchers must be added in a before function or a spec&#x27;);
      }
      var customMatchers = runnableResources[currentRunnable().id].customMatchers;
      for (var matcherName in matchersToAdd) {
        customMatchers[matcherName] = matchersToAdd[matcherName];
      }
    };

    j$.Expectation.addCoreMatchers(j$.matchers);

    var nextSpecId = 0;
    var getNextSpecId = function() {
      return &#x27;spec&#x27; + nextSpecId++;
    };

    var nextSuiteId = 0;
    var getNextSuiteId = function() {
      return &#x27;suite&#x27; + nextSuiteId++;
    };

    var expectationFactory = function(actual, spec) {
      return j$.Expectation.Factory({
        util: j$.matchersUtil,
        customEqualityTesters: runnableResources[spec.id].customEqualityTesters,
        customMatchers: runnableResources[spec.id].customMatchers,
        actual: actual,
        addExpectationResult: addExpectationResult
      });

      function addExpectationResult(passed, result) {
        return spec.addExpectationResult(passed, result);
      }
    };

    var defaultResourcesForRunnable = function(id, parentRunnableId) {
      var resources = {spies: [], customEqualityTesters: [], customMatchers: {}};

      if(runnableResources[parentRunnableId]){
        resources.customEqualityTesters = j$.util.clone(runnableResources[parentRunnableId].customEqualityTesters);
        resources.customMatchers = j$.util.clone(runnableResources[parentRunnableId].customMatchers);
      }

      runnableResources[id] = resources;
    };

    var clearResourcesForRunnable = function(id) {
        spyRegistry.clearSpies();
        delete runnableResources[id];
    };

    var beforeAndAfterFns = function(suite) {
      return function() {
        var befores = [],
          afters = [];

        while(suite) {
          befores = befores.concat(suite.beforeFns);
          afters = afters.concat(suite.afterFns);

          suite = suite.parentSuite;
        }

        return {
          befores: befores.reverse(),
          afters: afters
        };
      };
    };

    var getSpecName = function(spec, suite) {
      var fullName = [spec.description],
          suiteFullName = suite.getFullName();

      if (suiteFullName !== &#x27;&#x27;) {
        fullName.unshift(suiteFullName);
      }
      return fullName.join(&#x27; &#x27;);
    };

    // TODO: we may just be able to pass in the fn instead of wrapping here
    var buildExpectationResult = j$.buildExpectationResult,
        exceptionFormatter = new j$.ExceptionFormatter(),
        expectationResultFactory = function(attrs) {
          attrs.messageFormatter = exceptionFormat ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.formatErrorMsg = jRequire.formatErrorMsg();
j$.Any = jRequire.Any(j$);
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.<span class="apidocCodeKeywordSpan">Env</span>(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.ExceptionFormatter" id="apidoc.element.jasmine-core.ExceptionFormatter">
        function <span class="apidocSignatureSpan">jasmine-core.</span>ExceptionFormatter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ExceptionFormatter = function () {
  function ExceptionFormatter() {
    this.message = function(error) {
      var message = &#x27;&#x27;;

      if (error.name &#x26;&#x26; error.message) {
        message += error.name + &#x27;: &#x27; + error.message;
      } else {
        message += error.toString() + &#x27; thrown&#x27;;
      }

      if (error.fileName || error.sourceURL) {
        message += &#x27; in &#x27; + (error.fileName || error.sourceURL);
      }

      if (error.line || error.lineNumber) {
        message += &#x27; (line &#x27; + (error.line || error.lineNumber) + &#x27;)&#x27;;
      }

      return message;
    };

    this.stack = function(error) {
      return error ? error.stack : null;
    };
  }

  return ExceptionFormatter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.Any = jRequire.Any(j$);
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.<span class="apidocCodeKeywordSpan">ExceptionFormatter</span>();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.Expectation" id="apidoc.element.jasmine-core.Expectation">
        function <span class="apidocSignatureSpan">jasmine-core.</span>Expectation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Expectation = function () {

  function Expectation(options) {
    this.util = options.util || { buildFailureMessage: function() {} };
    this.customEqualityTesters = options.customEqualityTesters || [];
    this.actual = options.actual;
    this.addExpectationResult = options.addExpectationResult || function(){};
    this.isNot = options.isNot;

    var customMatchers = options.customMatchers || {};
    for (var matcherName in customMatchers) {
      this[matcherName] = Expectation.prototype.wrapCompare(matcherName, customMatchers[matcherName]);
    }
  }

  Expectation.prototype.wrapCompare = function(name, matcherFactory) {
    return function() {
      var args = Array.prototype.slice.call(arguments, 0),
        expected = args.slice(0),
        message = &#x27;&#x27;;

      args.unshift(this.actual);

      var matcher = matcherFactory(this.util, this.customEqualityTesters),
          matcherCompare = matcher.compare;

      function defaultNegativeCompare() {
        var result = matcher.compare.apply(null, args);
        result.pass = !result.pass;
        return result;
      }

      if (this.isNot) {
        matcherCompare = matcher.negativeCompare || defaultNegativeCompare;
      }

      var result = matcherCompare.apply(null, args);

      if (!result.pass) {
        if (!result.message) {
          args.unshift(this.isNot);
          args.unshift(name);
          message = this.util.buildFailureMessage.apply(null, args);
        } else {
          if (Object.prototype.toString.apply(result.message) === &#x27;[object Function]&#x27;) {
            message = result.message();
          } else {
            message = result.message;
          }
        }
      }

      if (expected.length == 1) {
        expected = expected[0];
      }

      // TODO: how many of these params are needed?
      this.addExpectationResult(
        result.pass,
        {
          matcherName: name,
          passed: result.pass,
          message: message,
          actual: this.actual,
          expected: expected // TODO: this may need to be arrayified/sliced
        }
      );
    };
  };

  Expectation.addCoreMatchers = function(matchers) {
    var prototype = Expectation.prototype;
    for (var matcherName in matchers) {
      var matcher = matchers[matcherName];
      prototype[matcherName] = prototype.wrapCompare(matcherName, matcher);
    }
  };

  Expectation.Factory = function(options) {
    options = options || {};

    var expect = new Expectation(options);

    // TODO: this would be nice as its own Object - NegativeExpectation
    // TODO: copy instead of mutate options
    options.isNot = true;
    expect.not = new Expectation(options);

    return expect;
  };

  return Expectation;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.<span class="apidocCodeKeywordSpan">Expectation</span>();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.JsApiReporter" id="apidoc.element.jasmine-core.JsApiReporter">
        function <span class="apidocSignatureSpan">jasmine-core.</span>JsApiReporter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JsApiReporter = function () {

  var noopTimer = {
    start: function(){},
    elapsed: function(){ return 0; }
  };

  function JsApiReporter(options) {
    var timer = options.timer || noopTimer,
        status = &#x27;loaded&#x27;;

    this.started = false;
    this.finished = false;
    this.runDetails = {};

    this.jasmineStarted = function() {
      this.started = true;
      status = &#x27;started&#x27;;
      timer.start();
    };

    var executionTime;

    this.jasmineDone = function(runDetails) {
      this.finished = true;
      this.runDetails = runDetails;
      executionTime = timer.elapsed();
      status = &#x27;done&#x27;;
    };

    this.status = function() {
      return status;
    };

    var suites = [],
      suites_hash = {};

    this.suiteStarted = function(result) {
      suites_hash[result.id] = result;
    };

    this.suiteDone = function(result) {
      storeSuite(result);
    };

    this.suiteResults = function(index, length) {
      return suites.slice(index, index + length);
    };

    function storeSuite(result) {
      suites.push(result);
      suites_hash[result.id] = result;
    }

    this.suites = function() {
      return suites_hash;
    };

    var specs = [];

    this.specDone = function(result) {
      specs.push(result);
    };

    this.specResults = function(index, length) {
      return specs.slice(index, index + length);
    };

    this.specs = function() {
      return specs;
    };

    this.executionTime = function() {
      return executionTime;
    };

  }

  return JsApiReporter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.<span class="apidocCodeKeywordSpan">JsApiReporter</span>();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.Spec(j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.MockDate" id="apidoc.element.jasmine-core.MockDate">
        function <span class="apidocSignatureSpan">jasmine-core.</span>MockDate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MockDate = function () {
  function MockDate(global) {
    var self = this;
    var currentTime = 0;

    if (!global || !global.Date) {
      self.install = function() {};
      self.tick = function() {};
      self.uninstall = function() {};
      return self;
    }

    var GlobalDate = global.Date;

    self.install = function(mockDate) {
      if (mockDate instanceof GlobalDate) {
        currentTime = mockDate.getTime();
      } else {
        currentTime = new GlobalDate().getTime();
      }

      global.Date = FakeDate;
    };

    self.tick = function(millis) {
      millis = millis || 0;
      currentTime = currentTime + millis;
    };

    self.uninstall = function() {
      currentTime = 0;
      global.Date = GlobalDate;
    };

    createDateProperties();

    return self;

    function FakeDate() {
      switch(arguments.length) {
        case 0:
          return new GlobalDate(currentTime);
        case 1:
          return new GlobalDate(arguments[0]);
        case 2:
          return new GlobalDate(arguments[0], arguments[1]);
        case 3:
          return new GlobalDate(arguments[0], arguments[1], arguments[2]);
        case 4:
          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3]);
        case 5:
          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],
                                arguments[4]);
        case 6:
          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],
                                arguments[4], arguments[5]);
        default:
          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],
                                arguments[4], arguments[5], arguments[6]);
      }
    }

    function createDateProperties() {
      FakeDate.prototype = GlobalDate.prototype;

      FakeDate.now = function() {
        if (GlobalDate.now) {
          return currentTime;
        } else {
          throw new Error(&#x27;Browser does not support Date.now()&#x27;);
        }
      };

      FakeDate.toSource = GlobalDate.toSource;
      FakeDate.toString = GlobalDate.toString;
      FakeDate.parse = GlobalDate.parse;
      FakeDate.UTC = GlobalDate.UTC;
    }
	}

  return MockDate;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
jRequire.base(j$, jasmineGlobal);
j$.util = jRequire.util();
j$.errors = jRequire.errors();
j$.formatErrorMsg = jRequire.formatErrorMsg();
j$.Any = jRequire.Any(j$);
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.<span class="apidocCodeKeywordSpan">MockDate</span>();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.ObjectContaining" id="apidoc.element.jasmine-core.ObjectContaining">
        function <span class="apidocSignatureSpan">jasmine-core.</span>ObjectContaining
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ObjectContaining = function (j$) {

  function ObjectContaining(sample) {
    this.sample = sample;
  }

  function getPrototype(obj) {
    if (Object.getPrototypeOf) {
      return Object.getPrototypeOf(obj);
    }

    if (obj.constructor.prototype == obj) {
      return null;
    }

    return obj.constructor.prototype;
  }

  function hasProperty(obj, property) {
    if (!obj) {
      return false;
    }

    if (Object.prototype.hasOwnProperty.call(obj, property)) {
      return true;
    }

    return hasProperty(getPrototype(obj), property);
  }

  ObjectContaining.prototype.asymmetricMatch = function(other) {
    if (typeof(this.sample) !== &#x27;object&#x27;) { throw new Error(&#x27;You must provide an object to objectContaining, not \&#x27;&#x27;+this.sample
+&#x27;\&#x27;.&#x27;); }

    for (var property in this.sample) {
      if (!hasProperty(other, property) ||
          !j$.matchersUtil.equals(this.sample[property], other[property])) {
        return false;
      }
    }

    return true;
  };

  ObjectContaining.prototype.jasmineToString = function() {
    return &#x27;&#x3c;jasmine.objectContaining(&#x27; + j$.pp(this.sample) + &#x27;)&#x3e;&#x27;;
  };

  return ObjectContaining;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.<span class="apidocCodeKeywordSpan">ObjectContaining</span>(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.Spec(j$);
j$.SpyRegistry = jRequire.SpyRegistry(j$);
j$.SpyStrategy = jRequire.SpyStrategy(j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.Order" id="apidoc.element.jasmine-core.Order">
        function <span class="apidocSignatureSpan">jasmine-core.</span>Order
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Order = function () {
  function Order(options) {
    this.random = &#x27;random&#x27; in options ? options.random : true;
    var seed = this.seed = options.seed || generateSeed();
    this.sort = this.random ? randomOrder : naturalOrder;

    function naturalOrder(items) {
      return items;
    }

    function randomOrder(items) {
      var copy = items.slice();
      copy.sort(function(a, b) {
        return jenkinsHash(seed + a.id) - jenkinsHash(seed + b.id);
      });
      return copy;
    }

    function generateSeed() {
      return String(Math.random()).slice(-5);
    }

    // Bob Jenkins One-at-a-Time Hash algorithm is a non-cryptographic hash function
    // used to get a different output when the key changes slighly.
    // We use your return to sort the children randomly in a consistent way when
    // used in conjunction with a seed

    function jenkinsHash(key) {
      var hash, i;
      for(hash = i = 0; i &#x3c; key.length; ++i) {
        hash += key.charCodeAt(i);
        hash += (hash &#x3c;&#x3c; 10);
        hash ^= (hash &#x3e;&#x3e; 6);
      }
      hash += (hash &#x3c;&#x3c; 3);
      hash ^= (hash &#x3e;&#x3e; 11);
      hash += (hash &#x3c;&#x3c; 15);
      return hash;
    }

  }

  return Order;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  j$.SpyRegistry = jRequire.SpyRegistry(j$);
  j$.SpyStrategy = jRequire.SpyStrategy(j$);
  j$.StringMatching = jRequire.StringMatching(j$);
  j$.Suite = jRequire.Suite(j$);
  j$.Timer = jRequire.Timer();
  j$.TreeProcessor = jRequire.TreeProcessor();
  j$.version = jRequire.version();
  j$.Order = jRequire.<span class="apidocCodeKeywordSpan">Order</span>();

  j$.matchers = jRequire.requireMatchers(jRequire, j$);

  return j$;
};

return getJasmineRequire;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.QueueRunner" id="apidoc.element.jasmine-core.QueueRunner">
        function <span class="apidocSignatureSpan">jasmine-core.</span>QueueRunner
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">QueueRunner = function (j$) {

  function once(fn) {
    var called = false;
    return function() {
      if (!called) {
        called = true;
        fn();
      }
      return null;
    };
  }

  function QueueRunner(attrs) {
    this.queueableFns = attrs.queueableFns || [];
    this.onComplete = attrs.onComplete || function() {};
    this.clearStack = attrs.clearStack || function(fn) {fn();};
    this.onException = attrs.onException || function() {};
    this.catchException = attrs.catchException || function() { return true; };
    this.userContext = attrs.userContext || {};
    this.timeout = attrs.timeout || {setTimeout: setTimeout, clearTimeout: clearTimeout};
    this.fail = attrs.fail || function() {};
  }

  QueueRunner.prototype.execute = function() {
    this.run(this.queueableFns, 0);
  };

  QueueRunner.prototype.run = function(queueableFns, recursiveIndex) {
    var length = queueableFns.length,
      self = this,
      iterativeIndex;


    for(iterativeIndex = recursiveIndex; iterativeIndex &#x3c; length; iterativeIndex++) {
      var queueableFn = queueableFns[iterativeIndex];
      if (queueableFn.fn.length &#x3e; 0) {
        attemptAsync(queueableFn);
        return;
      } else {
        attemptSync(queueableFn);
      }
    }

    var runnerDone = iterativeIndex &#x3e;= length;

    if (runnerDone) {
      this.clearStack(this.onComplete);
    }

    function attemptSync(queueableFn) {
      try {
        queueableFn.fn.call(self.userContext);
      } catch (e) {
        handleException(e, queueableFn);
      }
    }

    function attemptAsync(queueableFn) {
      var clearTimeout = function () {
          Function.prototype.apply.apply(self.timeout.clearTimeout, [j$.getGlobal(), [timeoutId]]);
        },
        next = once(function () {
          clearTimeout(timeoutId);
          self.run(queueableFns, iterativeIndex + 1);
        }),
        timeoutId;

      next.fail = function() {
        self.fail.apply(null, arguments);
        next();
      };

      if (queueableFn.timeout) {
        timeoutId = Function.prototype.apply.apply(self.timeout.setTimeout, [j$.getGlobal(), [function() {
          var error = new Error(&#x27;Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL
.&#x27;);
          onException(error);
          next();
        }, queueableFn.timeout()]]);
      }

      try {
        queueableFn.fn.call(self.userContext, next);
      } catch (e) {
        handleException(e, queueableFn);
        next();
      }
    }

    function onException(e) {
      self.onException(e);
    }

    function handleException(e, queueableFn) {
      onException(e);
      if (!self.catchException(e)) {
        //TODO: set a var when we catch an exception and
        //use a finally block to close the loop in a nice way..
        throw e;
      }
    }
  };

  return QueueRunner;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.<span class="apidocCodeKeywordSpan">QueueRunner</span>(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.Spec(j$);
j$.SpyRegistry = jRequire.SpyRegistry(j$);
j$.SpyStrategy = jRequire.SpyStrategy(j$);
j$.StringMatching = jRequire.StringMatching(j$);
j$.Suite = jRequire.Suite(j$);
j$.Timer = jRequire.Timer();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.ReportDispatcher" id="apidoc.element.jasmine-core.ReportDispatcher">
        function <span class="apidocSignatureSpan">jasmine-core.</span>ReportDispatcher
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ReportDispatcher = function () {
  function ReportDispatcher(methods) {

    var dispatchedMethods = methods || [];

    for (var i = 0; i &#x3c; dispatchedMethods.length; i++) {
      var method = dispatchedMethods[i];
      this[method] = (function(m) {
        return function() {
          dispatch(m, arguments);
        };
      }(method));
    }

    var reporters = [];
    var fallbackReporter = null;

    this.addReporter = function(reporter) {
      reporters.push(reporter);
    };

    this.provideFallbackReporter = function(reporter) {
      fallbackReporter = reporter;
    };

    this.clearReporters = function() {
      reporters = [];
    };

    return this;

    function dispatch(method, args) {
      if (reporters.length === 0 &#x26;&#x26; fallbackReporter !== null) {
          reporters.push(fallbackReporter);
      }
      for (var i = 0; i &#x3c; reporters.length; i++) {
        var reporter = reporters[i];
        if (reporter[method]) {
          reporter[method].apply(reporter, args);
        }
      }
    }
  }

  return ReportDispatcher;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.<span class="apidocCodeKeywordSpan">ReportDispatcher</span>();
j$.Spec = jRequire.Spec(j$);
j$.SpyRegistry = jRequire.SpyRegistry(j$);
j$.SpyStrategy = jRequire.SpyStrategy(j$);
j$.StringMatching = jRequire.StringMatching(j$);
j$.Suite = jRequire.Suite(j$);
j$.Timer = jRequire.Timer();
j$.TreeProcessor = jRequire.TreeProcessor();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.Spec" id="apidoc.element.jasmine-core.Spec">
        function <span class="apidocSignatureSpan">jasmine-core.</span>Spec
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Spec = function (j$) {
  function Spec(attrs) {
    this.expectationFactory = attrs.expectationFactory;
    this.resultCallback = attrs.resultCallback || function() {};
    this.id = attrs.id;
    this.description = attrs.description || &#x27;&#x27;;
    this.queueableFn = attrs.queueableFn;
    this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };
    this.userContext = attrs.userContext || function() { return {}; };
    this.onStart = attrs.onStart || function() {};
    this.getSpecName = attrs.getSpecName || function() { return &#x27;&#x27;; };
    this.expectationResultFactory = attrs.expectationResultFactory || function() { };
    this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};
    this.catchingExceptions = attrs.catchingExceptions || function() { return true; };
    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;

    if (!this.queueableFn.fn) {
      this.pend();
    }

    this.result = {
      id: this.id,
      description: this.description,
      fullName: this.getFullName(),
      failedExpectations: [],
      passedExpectations: [],
      pendingReason: &#x27;&#x27;
    };
  }

  Spec.prototype.addExpectationResult = function(passed, data, isError) {
    var expectationResult = this.expectationResultFactory(data);
    if (passed) {
      this.result.passedExpectations.push(expectationResult);
    } else {
      this.result.failedExpectations.push(expectationResult);

      if (this.throwOnExpectationFailure &#x26;&#x26; !isError) {
        throw new j$.errors.ExpectationFailed();
      }
    }
  };

  Spec.prototype.expect = function(actual) {
    return this.expectationFactory(actual, this);
  };

  Spec.prototype.execute = function(onComplete, enabled) {
    var self = this;

    this.onStart(this);

    if (!this.isExecutable() || this.markedPending || enabled === false) {
      complete(enabled);
      return;
    }

    var fns = this.beforeAndAfterFns();
    var allFns = fns.befores.concat(this.queueableFn).concat(fns.afters);

    this.queueRunnerFactory({
      queueableFns: allFns,
      onException: function() { self.onException.apply(self, arguments); },
      onComplete: complete,
      userContext: this.userContext()
    });

    function complete(enabledAgain) {
      self.result.status = self.status(enabledAgain);
      self.resultCallback(self.result);

      if (onComplete) {
        onComplete();
      }
    }
  };

  Spec.prototype.onException = function onException(e) {
    if (Spec.isPendingSpecException(e)) {
      this.pend(extractCustomPendingMessage(e));
      return;
    }

    if (e instanceof j$.errors.ExpectationFailed) {
      return;
    }

    this.addExpectationResult(false, {
      matcherName: &#x27;&#x27;,
      passed: false,
      expected: &#x27;&#x27;,
      actual: &#x27;&#x27;,
      error: e
    }, true);
  };

  Spec.prototype.disable = function() {
    this.disabled = true;
  };

  Spec.prototype.pend = function(message) {
    this.markedPending = true;
    if (message) {
      this.result.pendingReason = message;
    }
  };

  Spec.prototype.getResult = function() {
    this.result.status = this.status();
    return this.result;
  };

  Spec.prototype.status = function(enabled) {
    if (this.disabled || enabled === false) {
      return &#x27;disabled&#x27;;
    }

    if (this.markedPending) {
      return &#x27;pending&#x27;;
    }

    if (this.result.failedExpectations.length &#x3e; 0) {
      return &#x27;failed&#x27;;
    } else {
      return &#x27;passed&#x27;;
    }
  };

  Spec.prototype.isExecutable = function() {
    return !this.disabled;
  };

  Spec.prototype.getFullName = function() {
    return this.getSpecName(this);
  };

  var extractCustomPendingMessage = function(e) {
    var fullMessage = e.toString(),
        boilerplateStart = fullMessage.indexOf(Spec.pendingSpecExceptionMessage),
        boilerplateEnd = boilerplateStart + Spec.pendingSpecExceptionMessage.length;

    return fullMessage.substr(boilerplateEnd);
  };

  Spec.pendingSpecExceptionMessage = &#x27;=&#x3e; marked Pending&#x27;;

  Spec.isPendingSpecException = function(e) {
    return !!(e &#x26;&#x26; e.toString &#x26;&#x26; e.toString().inde ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.<span class="apidocCodeKeywordSpan">Spec</span>(j$);
j$.SpyRegistry = jRequire.SpyRegistry(j$);
j$.SpyStrategy = jRequire.SpyStrategy(j$);
j$.StringMatching = jRequire.StringMatching(j$);
j$.Suite = jRequire.Suite(j$);
j$.Timer = jRequire.Timer();
j$.TreeProcessor = jRequire.TreeProcessor();
j$.version = jRequire.version();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.SpyRegistry" id="apidoc.element.jasmine-core.SpyRegistry">
        function <span class="apidocSignatureSpan">jasmine-core.</span>SpyRegistry
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SpyRegistry = function (j$) {

  var getErrorMsg = j$.formatErrorMsg(&#x27;&#x3c;spyOn&#x3e;&#x27;, &#x27;spyOn(&#x3c;object&#x3e;, &#x3c;methodName&#x3e;)&#x27;);

  function SpyRegistry(options) {
    options = options || {};
    var currentSpies = options.currentSpies || function() { return []; };

    this.allowRespy = function(allow){
      this.respy = allow;
    };

    this.spyOn = function(obj, methodName) {

      if (j$.util.isUndefined(obj)) {
        throw new Error(getErrorMsg(&#x27;could not find an object to spy upon for &#x27; + methodName + &#x27;()&#x27;));
      }

      if (j$.util.isUndefined(methodName)) {
        throw new Error(getErrorMsg(&#x27;No method name supplied&#x27;));
      }

      if (j$.util.isUndefined(obj[methodName])) {
        throw new Error(getErrorMsg(methodName + &#x27;() method does not exist&#x27;));
      }

      if (obj[methodName] &#x26;&#x26; j$.isSpy(obj[methodName])  ) {
        if ( !!this.respy ){
          return obj[methodName];
        }else {
          throw new Error(getErrorMsg(methodName + &#x27; has already been spied upon&#x27;));
        }
      }

      var descriptor;
      try {
        descriptor = Object.getOwnPropertyDescriptor(obj, methodName);
      } catch(e) {
        // IE 8 doesn&#x27;t support `definePropery` on non-DOM nodes
      }

      if (descriptor &#x26;&#x26; !(descriptor.writable || descriptor.set)) {
        throw new Error(getErrorMsg(methodName + &#x27; is not declared writable or has no setter&#x27;));
      }

      var originalMethod = obj[methodName],
        spiedMethod = j$.createSpy(methodName, originalMethod),
        restoreStrategy;

      if (Object.prototype.hasOwnProperty.call(obj, methodName)) {
        restoreStrategy = function() {
          obj[methodName] = originalMethod;
        };
      } else {
        restoreStrategy = function() {
          if (!delete obj[methodName]) {
            obj[methodName] = originalMethod;
          }
        };
      }

      currentSpies().push({
        restoreObjectToOriginalState: restoreStrategy
      });

      obj[methodName] = spiedMethod;

      return spiedMethod;
    };

    this.clearSpies = function() {
      var spies = currentSpies();
      for (var i = spies.length - 1; i &#x3e;= 0; i--) {
        var spyEntry = spies[i];
        spyEntry.restoreObjectToOriginalState();
      }
    };
  }

  return SpyRegistry;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.Spec(j$);
j$.SpyRegistry = jRequire.<span class="apidocCodeKeywordSpan">SpyRegistry</span>(j$);
j$.SpyStrategy = jRequire.SpyStrategy(j$);
j$.StringMatching = jRequire.StringMatching(j$);
j$.Suite = jRequire.Suite(j$);
j$.Timer = jRequire.Timer();
j$.TreeProcessor = jRequire.TreeProcessor();
j$.version = jRequire.version();
j$.Order = jRequire.Order();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.SpyStrategy" id="apidoc.element.jasmine-core.SpyStrategy">
        function <span class="apidocSignatureSpan">jasmine-core.</span>SpyStrategy
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SpyStrategy = function (j$) {

  function SpyStrategy(options) {
    options = options || {};

    var identity = options.name || &#x27;unknown&#x27;,
        originalFn = options.fn || function() {},
        getSpy = options.getSpy || function() {},
        plan = function() {};

    this.identity = function() {
      return identity;
    };

    this.exec = function() {
      return plan.apply(this, arguments);
    };

    this.callThrough = function() {
      plan = originalFn;
      return getSpy();
    };

    this.returnValue = function(value) {
      plan = function() {
        return value;
      };
      return getSpy();
    };

    this.returnValues = function() {
      var values = Array.prototype.slice.call(arguments);
      plan = function () {
        return values.shift();
      };
      return getSpy();
    };

    this.throwError = function(something) {
      var error = (something instanceof Error) ? something : new Error(something);
      plan = function() {
        throw error;
      };
      return getSpy();
    };

    this.callFake = function(fn) {
      if(!j$.isFunction_(fn)) {
        throw new Error(&#x27;Argument passed to callFake should be a function, got &#x27; + fn);
      }
      plan = fn;
      return getSpy();
    };

    this.stub = function(fn) {
      plan = function() {};
      return getSpy();
    };
  }

  return SpyStrategy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.Spec(j$);
j$.SpyRegistry = jRequire.SpyRegistry(j$);
j$.SpyStrategy = jRequire.<span class="apidocCodeKeywordSpan">SpyStrategy</span>(j$);
j$.StringMatching = jRequire.StringMatching(j$);
j$.Suite = jRequire.Suite(j$);
j$.Timer = jRequire.Timer();
j$.TreeProcessor = jRequire.TreeProcessor();
j$.version = jRequire.version();
j$.Order = jRequire.Order();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.StringMatching" id="apidoc.element.jasmine-core.StringMatching">
        function <span class="apidocSignatureSpan">jasmine-core.</span>StringMatching
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">StringMatching = function (j$) {

  function StringMatching(expected) {
    if (!j$.isString_(expected) &#x26;&#x26; !j$.isA_(&#x27;RegExp&#x27;, expected)) {
      throw new Error(&#x27;Expected is not a String or a RegExp&#x27;);
    }

    this.regexp = new RegExp(expected);
  }

  StringMatching.prototype.asymmetricMatch = function(other) {
    return this.regexp.test(other);
  };

  StringMatching.prototype.jasmineToString = function() {
    return &#x27;&#x3c;jasmine.stringMatching(&#x27; + this.regexp + &#x27;)&#x3e;&#x27;;
  };

  return StringMatching;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.Spec(j$);
j$.SpyRegistry = jRequire.SpyRegistry(j$);
j$.SpyStrategy = jRequire.SpyStrategy(j$);
j$.StringMatching = jRequire.<span class="apidocCodeKeywordSpan">StringMatching</span>(j$);
j$.Suite = jRequire.Suite(j$);
j$.Timer = jRequire.Timer();
j$.TreeProcessor = jRequire.TreeProcessor();
j$.version = jRequire.version();
j$.Order = jRequire.Order();

j$.matchers = jRequire.requireMatchers(jRequire, j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.Suite" id="apidoc.element.jasmine-core.Suite">
        function <span class="apidocSignatureSpan">jasmine-core.</span>Suite
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Suite = function (j$) {
  function Suite(attrs) {
    this.env = attrs.env;
    this.id = attrs.id;
    this.parentSuite = attrs.parentSuite;
    this.description = attrs.description;
    this.expectationFactory = attrs.expectationFactory;
    this.expectationResultFactory = attrs.expectationResultFactory;
    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;

    this.beforeFns = [];
    this.afterFns = [];
    this.beforeAllFns = [];
    this.afterAllFns = [];
    this.disabled = false;

    this.children = [];

    this.result = {
      id: this.id,
      description: this.description,
      fullName: this.getFullName(),
      failedExpectations: []
    };
  }

  Suite.prototype.expect = function(actual) {
    return this.expectationFactory(actual, this);
  };

  Suite.prototype.getFullName = function() {
    var fullName = [];
    for (var parentSuite = this; parentSuite; parentSuite = parentSuite.parentSuite) {
      if (parentSuite.parentSuite) {
        fullName.unshift(parentSuite.description);
      }
    }
    return fullName.join(&#x27; &#x27;);
  };

  Suite.prototype.disable = function() {
    this.disabled = true;
  };

  Suite.prototype.pend = function(message) {
    this.markedPending = true;
  };

  Suite.prototype.beforeEach = function(fn) {
    this.beforeFns.unshift(fn);
  };

  Suite.prototype.beforeAll = function(fn) {
    this.beforeAllFns.push(fn);
  };

  Suite.prototype.afterEach = function(fn) {
    this.afterFns.unshift(fn);
  };

  Suite.prototype.afterAll = function(fn) {
    this.afterAllFns.push(fn);
  };

  Suite.prototype.addChild = function(child) {
    this.children.push(child);
  };

  Suite.prototype.status = function() {
    if (this.disabled) {
      return &#x27;disabled&#x27;;
    }

    if (this.markedPending) {
      return &#x27;pending&#x27;;
    }

    if (this.result.failedExpectations.length &#x3e; 0) {
      return &#x27;failed&#x27;;
    } else {
      return &#x27;finished&#x27;;
    }
  };

  Suite.prototype.isExecutable = function() {
    return !this.disabled;
  };

  Suite.prototype.canBeReentered = function() {
    return this.beforeAllFns.length === 0 &#x26;&#x26; this.afterAllFns.length === 0;
  };

  Suite.prototype.getResult = function() {
    this.result.status = this.status();
    return this.result;
  };

  Suite.prototype.sharedUserContext = function() {
    if (!this.sharedContext) {
      this.sharedContext = this.parentSuite ? clone(this.parentSuite.sharedUserContext()) : {};
    }

    return this.sharedContext;
  };

  Suite.prototype.clonedSharedUserContext = function() {
    return clone(this.sharedUserContext());
  };

  Suite.prototype.onException = function() {
    if (arguments[0] instanceof j$.errors.ExpectationFailed) {
      return;
    }

    if(isAfterAll(this.children)) {
      var data = {
        matcherName: &#x27;&#x27;,
        passed: false,
        expected: &#x27;&#x27;,
        actual: &#x27;&#x27;,
        error: arguments[0]
      };
      this.result.failedExpectations.push(this.expectationResultFactory(data));
    } else {
      for (var i = 0; i &#x3c; this.children.length; i++) {
        var child = this.children[i];
        child.onException.apply(child, arguments);
      }
    }
  };

  Suite.prototype.addExpectationResult = function () {
    if(isAfterAll(this.children) &#x26;&#x26; isFailure(arguments)){
      var data = arguments[1];
      this.result.failedExpectations.push(this.expectationResultFactory(data));
      if(this.throwOnExpectationFailure) {
        throw new j$.errors.ExpectationFailed();
      }
    } else {
      for (var i = 0; i &#x3c; this.children.length; i++) {
        var child = this.children[i];
        try {
          child.addExpectationResult.apply(child, arguments);
        } catch(e) {
          // keep going
        }
      }
    }
  };

  function isAfterAll(children) {
    return children &#x26;&#x26; children[0].result.status;
  }

  function isFailure(args) {
    return !args[0];
  }

  function clone(obj) {
    var clonedObj = {};
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        clonedObj[prop] = obj[prop];
      }
    }

    return clonedObj;
  }

  return Suite;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.Spec(j$);
j$.SpyRegistry = jRequire.SpyRegistry(j$);
j$.SpyStrategy = jRequire.SpyStrategy(j$);
j$.StringMatching = jRequire.StringMatching(j$);
j$.Suite = jRequire.<span class="apidocCodeKeywordSpan">Suite</span>(j$);
j$.Timer = jRequire.Timer();
j$.TreeProcessor = jRequire.TreeProcessor();
j$.version = jRequire.version();
j$.Order = jRequire.Order();

j$.matchers = jRequire.requireMatchers(jRequire, j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.Timer" id="apidoc.element.jasmine-core.Timer">
        function <span class="apidocSignatureSpan">jasmine-core.</span>Timer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Timer = function () {
  var defaultNow = (function(Date) {
    return function() { return new Date().getTime(); };
  })(Date);

  function Timer(options) {
    options = options || {};

    var now = options.now || defaultNow,
      startTime;

    this.start = function() {
      startTime = now();
    };

    this.elapsed = function() {
      return now() - startTime;
    };
  }

  return Timer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.Spec(j$);
j$.SpyRegistry = jRequire.SpyRegistry(j$);
j$.SpyStrategy = jRequire.SpyStrategy(j$);
j$.StringMatching = jRequire.StringMatching(j$);
j$.Suite = jRequire.Suite(j$);
j$.Timer = jRequire.<span class="apidocCodeKeywordSpan">Timer</span>();
j$.TreeProcessor = jRequire.TreeProcessor();
j$.version = jRequire.version();
j$.Order = jRequire.Order();

j$.matchers = jRequire.requireMatchers(jRequire, j$);

return j$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.TreeProcessor" id="apidoc.element.jasmine-core.TreeProcessor">
        function <span class="apidocSignatureSpan">jasmine-core.</span>TreeProcessor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TreeProcessor = function () {
  function TreeProcessor(attrs) {
    var tree = attrs.tree,
        runnableIds = attrs.runnableIds,
        queueRunnerFactory = attrs.queueRunnerFactory,
        nodeStart = attrs.nodeStart || function() {},
        nodeComplete = attrs.nodeComplete || function() {},
        orderChildren = attrs.orderChildren || function(node) { return node.children; },
        stats = { valid: true },
        processed = false,
        defaultMin = Infinity,
        defaultMax = 1 - Infinity;

    this.processTree = function() {
      processNode(tree, false);
      processed = true;
      return stats;
    };

    this.execute = function(done) {
      if (!processed) {
        this.processTree();
      }

      if (!stats.valid) {
        throw &#x27;invalid order&#x27;;
      }

      var childFns = wrapChildren(tree, 0);

      queueRunnerFactory({
        queueableFns: childFns,
        userContext: tree.sharedUserContext(),
        onException: function() {
          tree.onException.apply(tree, arguments);
        },
        onComplete: done
      });
    };

    function runnableIndex(id) {
      for (var i = 0; i &#x3c; runnableIds.length; i++) {
        if (runnableIds[i] === id) {
          return i;
        }
      }
    }

    function processNode(node, parentEnabled) {
      var executableIndex = runnableIndex(node.id);

      if (executableIndex !== undefined) {
        parentEnabled = true;
      }

      parentEnabled = parentEnabled &#x26;&#x26; node.isExecutable();

      if (!node.children) {
        stats[node.id] = {
          executable: parentEnabled &#x26;&#x26; node.isExecutable(),
          segments: [{
            index: 0,
            owner: node,
            nodes: [node],
            min: startingMin(executableIndex),
            max: startingMax(executableIndex)
          }]
        };
      } else {
        var hasExecutableChild = false;

        var orderedChildren = orderChildren(node);

        for (var i = 0; i &#x3c; orderedChildren.length; i++) {
          var child = orderedChildren[i];

          processNode(child, parentEnabled);

          if (!stats.valid) {
            return;
          }

          var childStats = stats[child.id];

          hasExecutableChild = hasExecutableChild || childStats.executable;
        }

        stats[node.id] = {
          executable: hasExecutableChild
        };

        segmentChildren(node, orderedChildren, stats[node.id], executableIndex);

        if (!node.canBeReentered() &#x26;&#x26; stats[node.id].segments.length &#x3e; 1) {
          stats = { valid: false };
        }
      }
    }

    function startingMin(executableIndex) {
      return executableIndex === undefined ? defaultMin : executableIndex;
    }

    function startingMax(executableIndex) {
      return executableIndex === undefined ? defaultMax : executableIndex;
    }

    function segmentChildren(node, orderedChildren, nodeStats, executableIndex) {
      var currentSegment = { index: 0, owner: node, nodes: [], min: startingMin(executableIndex), max: startingMax(executableIndex
) },
          result = [currentSegment],
          lastMax = defaultMax,
          orderedChildSegments = orderChildSegments(orderedChildren);

      function isSegmentBoundary(minIndex) {
        return lastMax !== defaultMax &#x26;&#x26; minIndex !== defaultMin &#x26;&#x26; lastMax &#x3c; minIndex - 1;
      }

      for (var i = 0; i &#x3c; orderedChildSegments.length; i++) {
        var childSegment = orderedChildSegments[i],
          maxIndex = childSegment.max,
          minIndex = childSegment.min;

        if (isSegmentBoundary(minIndex)) {
          currentSegment = {index: result.length, owner: node, nodes: [], min: defaultMin, max: defaultMax};
          result.push(currentSegment);
        }

        currentSegment.nodes.push(childSegment);
        currentSegment.min = Math.min(currentSegment.min, minIndex);
        currentSegment.max = Math.max(currentSegment.max, maxIndex);
        lastMax = maxIndex;
      }

      nodeStats.segments = result;
    }

    function orderChildSegments(children) {
      var specifiedOrder = [],
          unspecifiedOrder = []; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  j$.ReportDispatcher = jRequire.ReportDispatcher();
  j$.Spec = jRequire.Spec(j$);
  j$.SpyRegistry = jRequire.SpyRegistry(j$);
  j$.SpyStrategy = jRequire.SpyStrategy(j$);
  j$.StringMatching = jRequire.StringMatching(j$);
  j$.Suite = jRequire.Suite(j$);
  j$.Timer = jRequire.Timer();
  j$.TreeProcessor = jRequire.<span class="apidocCodeKeywordSpan">TreeProcessor</span>();
  j$.version = jRequire.version();
  j$.Order = jRequire.Order();

  j$.matchers = jRequire.requireMatchers(jRequire, j$);

  return j$;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.base" id="apidoc.element.jasmine-core.base">
        function <span class="apidocSignatureSpan">jasmine-core.</span>base
        <span class="apidocSignatureSpan">(j$, jasmineGlobal)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">base = function (j$, jasmineGlobal) {
  j$.unimplementedMethod_ = function() {
    throw new Error(&#x27;unimplemented method&#x27;);
  };

  j$.MAX_PRETTY_PRINT_DEPTH = 40;
  j$.MAX_PRETTY_PRINT_ARRAY_LENGTH = 100;
  j$.DEFAULT_TIMEOUT_INTERVAL = 5000;

  j$.getGlobal = function() {
    return jasmineGlobal;
  };

  j$.getEnv = function(options) {
    var env = j$.currentEnv_ = j$.currentEnv_ || new j$.Env(options);
    //jasmine. singletons in here (setTimeout blah blah).
    return env;
  };

  j$.isArray_ = function(value) {
    return j$.isA_(&#x27;Array&#x27;, value);
  };

  j$.isString_ = function(value) {
    return j$.isA_(&#x27;String&#x27;, value);
  };

  j$.isNumber_ = function(value) {
    return j$.isA_(&#x27;Number&#x27;, value);
  };

  j$.isFunction_ = function(value) {
    return j$.isA_(&#x27;Function&#x27;, value);
  };

  j$.isA_ = function(typeName, value) {
    return Object.prototype.toString.apply(value) === &#x27;[object &#x27; + typeName + &#x27;]&#x27;;
  };

  j$.isDomNode = function(obj) {
    return obj.nodeType &#x3e; 0;
  };

  j$.fnNameFor = function(func) {
    if (func.name) {
      return func.name;
    }

    var matches = func.toString().match(/^\s*function\s*(\w*)\s*\(/);
    return matches ? matches[1] : &#x27;&#x3c;anonymous&#x3e;&#x27;;
  };

  j$.any = function(clazz) {
    return new j$.Any(clazz);
  };

  j$.anything = function() {
    return new j$.Anything();
  };

  j$.objectContaining = function(sample) {
    return new j$.ObjectContaining(sample);
  };

  j$.stringMatching = function(expected) {
    return new j$.StringMatching(expected);
  };

  j$.arrayContaining = function(sample) {
    return new j$.ArrayContaining(sample);
  };

  j$.createSpy = function(name, originalFn) {

    var spyStrategy = new j$.SpyStrategy({
        name: name,
        fn: originalFn,
        getSpy: function() { return spy; }
      }),
      callTracker = new j$.CallTracker(),
      spy = function() {
        var callData = {
          object: this,
          args: Array.prototype.slice.apply(arguments)
        };

        callTracker.track(callData);
        var returnValue = spyStrategy.exec.apply(this, arguments);
        callData.returnValue = returnValue;

        return returnValue;
      };

    for (var prop in originalFn) {
      if (prop === &#x27;and&#x27; || prop === &#x27;calls&#x27;) {
        throw new Error(&#x27;Jasmine spies would overwrite the \&#x27;and\&#x27; and \&#x27;calls\&#x27; properties on the object being spied upon&#x27;);
      }

      spy[prop] = originalFn[prop];
    }

    spy.and = spyStrategy;
    spy.calls = callTracker;

    return spy;
  };

  j$.isSpy = function(putativeSpy) {
    if (!putativeSpy) {
      return false;
    }
    return putativeSpy.and instanceof j$.SpyStrategy &#x26;&#x26;
      putativeSpy.calls instanceof j$.CallTracker;
  };

  j$.createSpyObj = function(baseName, methodNames) {
    if (j$.isArray_(baseName) &#x26;&#x26; j$.util.isUndefined(methodNames)) {
      methodNames = baseName;
      baseName = &#x27;unknown&#x27;;
    }

    if (!j$.isArray_(methodNames) || methodNames.length === 0) {
      throw &#x27;createSpyObj requires a non-empty array of method names to create spies for&#x27;;
    }
    var obj = {};
    for (var i = 0; i &#x3c; methodNames.length; i++) {
      obj[methodNames[i]] = j$.createSpy(baseName + &#x27;.&#x27; + methodNames[i]);
    }
    return obj;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function getJasmineRequire() {
return jasmineRequire;
  }

  getJasmineRequire().core = function(jRequire) {
var j$ = {};

jRequire.<span class="apidocCodeKeywordSpan">base</span>(j$, jasmineGlobal);
j$.util = jRequire.util();
j$.errors = jRequire.errors();
j$.formatErrorMsg = jRequire.formatErrorMsg();
j$.Any = jRequire.Any(j$);
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.boot" id="apidoc.element.jasmine-core.boot">
        function <span class="apidocSignatureSpan">jasmine-core.</span>boot
        <span class="apidocSignatureSpan">(jasmineRequire)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">boot = function (jasmineRequire) {
  var jasmine = jasmineRequire.core(jasmineRequire);

  var consoleFns = require(&#x27;../console/console.js&#x27;);
  consoleFns.console(consoleFns, jasmine);

  var env = jasmine.getEnv();

  var jasmineInterface = jasmineRequire.interface(jasmine, env);

  extend(global, jasmineInterface);

  function extend(destination, source) {
    for (var property in source) destination[property] = source[property];
    return destination;
  }

  return jasmine;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.buildExpectationResult" id="apidoc.element.jasmine-core.buildExpectationResult">
        function <span class="apidocSignatureSpan">jasmine-core.</span>buildExpectationResult
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildExpectationResult = function () {
  function buildExpectationResult(options) {
    var messageFormatter = options.messageFormatter || function() {},
      stackFormatter = options.stackFormatter || function() {};

    var result = {
      matcherName: options.matcherName,
      message: message(),
      stack: stack(),
      passed: options.passed
    };

    if(!result.passed) {
      result.expected = options.expected;
      result.actual = options.actual;
    }

    return result;

    function message() {
      if (options.passed) {
        return &#x27;Passed.&#x27;;
      } else if (options.message) {
        return options.message;
      } else if (options.error) {
        return messageFormatter(options.error);
      }
      return &#x27;&#x27;;
    }

    function stack() {
      if (options.passed) {
        return &#x27;&#x27;;
      }

      var error = options.error;
      if (!error) {
        try {
          throw new Error(message());
        } catch (e) {
          error = e;
        }
      }
      return stackFormatter(error);
    }
  }

  return buildExpectationResult;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.<span class="apidocCodeKeywordSpan">buildExpectationResult</span>();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.core" id="apidoc.element.jasmine-core.core">
        function <span class="apidocSignatureSpan">jasmine-core.</span>core
        <span class="apidocSignatureSpan">(jRequire)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">core = function (jRequire) {
  var j$ = {};

  jRequire.base(j$, jasmineGlobal);
  j$.util = jRequire.util();
  j$.errors = jRequire.errors();
  j$.formatErrorMsg = jRequire.formatErrorMsg();
  j$.Any = jRequire.Any(j$);
  j$.Anything = jRequire.Anything(j$);
  j$.CallTracker = jRequire.CallTracker(j$);
  j$.MockDate = jRequire.MockDate();
  j$.Clock = jRequire.Clock();
  j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
  j$.Env = jRequire.Env(j$);
  j$.ExceptionFormatter = jRequire.ExceptionFormatter();
  j$.Expectation = jRequire.Expectation();
  j$.buildExpectationResult = jRequire.buildExpectationResult();
  j$.JsApiReporter = jRequire.JsApiReporter();
  j$.matchersUtil = jRequire.matchersUtil(j$);
  j$.ObjectContaining = jRequire.ObjectContaining(j$);
  j$.ArrayContaining = jRequire.ArrayContaining(j$);
  j$.pp = jRequire.pp(j$);
  j$.QueueRunner = jRequire.QueueRunner(j$);
  j$.ReportDispatcher = jRequire.ReportDispatcher();
  j$.Spec = jRequire.Spec(j$);
  j$.SpyRegistry = jRequire.SpyRegistry(j$);
  j$.SpyStrategy = jRequire.SpyStrategy(j$);
  j$.StringMatching = jRequire.StringMatching(j$);
  j$.Suite = jRequire.Suite(j$);
  j$.Timer = jRequire.Timer();
  j$.TreeProcessor = jRequire.TreeProcessor();
  j$.version = jRequire.version();
  j$.Order = jRequire.Order();

  j$.matchers = jRequire.requireMatchers(jRequire, j$);

  return j$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
module.exports = function(jasmineRequire) {
var jasmine = jasmineRequire.<span class="apidocCodeKeywordSpan">core</span>(jasmineRequire);

var consoleFns = require(&#x27;../console/console.js&#x27;);
consoleFns.console(consoleFns, jasmine);

var env = jasmine.getEnv();

var jasmineInterface = jasmineRequire.interface(jasmine, env);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.errors" id="apidoc.element.jasmine-core.errors">
        function <span class="apidocSignatureSpan">jasmine-core.</span>errors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">errors = function () {
  function ExpectationFailed() {}

  ExpectationFailed.prototype = new Error();
  ExpectationFailed.prototype.constructor = ExpectationFailed;

  return {
    ExpectationFailed: ExpectationFailed
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  getJasmineRequire().core = function(jRequire) {
var j$ = {};

jRequire.base(j$, jasmineGlobal);
j$.util = jRequire.util();
j$.errors = jRequire.<span class="apidocCodeKeywordSpan">errors</span>();
j$.formatErrorMsg = jRequire.formatErrorMsg();
j$.Any = jRequire.Any(j$);
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.formatErrorMsg" id="apidoc.element.jasmine-core.formatErrorMsg">
        function <span class="apidocSignatureSpan">jasmine-core.</span>formatErrorMsg
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">formatErrorMsg = function () {
  function generateErrorMsg(domain, usage) {
    var usageDefinition = usage ? &#x27;\nUsage: &#x27; + usage : &#x27;&#x27;;

    return function errorMsg(msg) {
      return domain + &#x27; : &#x27; + msg + usageDefinition;
    };
  }

  return generateErrorMsg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  getJasmineRequire().core = function(jRequire) {
var j$ = {};

jRequire.base(j$, jasmineGlobal);
j$.util = jRequire.util();
j$.errors = jRequire.errors();
j$.formatErrorMsg = jRequire.<span class="apidocCodeKeywordSpan">formatErrorMsg</span>();
j$.Any = jRequire.Any(j$);
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.interface" id="apidoc.element.jasmine-core.interface">
        function <span class="apidocSignatureSpan">jasmine-core.</span>interface
        <span class="apidocSignatureSpan">(jasmine, env)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interface = function (jasmine, env) {
  var jasmineInterface = {
    describe: function(description, specDefinitions) {
      return env.describe(description, specDefinitions);
    },

    xdescribe: function(description, specDefinitions) {
      return env.xdescribe(description, specDefinitions);
    },

    fdescribe: function(description, specDefinitions) {
      return env.fdescribe(description, specDefinitions);
    },

    it: function() {
      return env.it.apply(env, arguments);
    },

    xit: function() {
      return env.xit.apply(env, arguments);
    },

    fit: function() {
      return env.fit.apply(env, arguments);
    },

    beforeEach: function() {
      return env.beforeEach.apply(env, arguments);
    },

    afterEach: function() {
      return env.afterEach.apply(env, arguments);
    },

    beforeAll: function() {
      return env.beforeAll.apply(env, arguments);
    },

    afterAll: function() {
      return env.afterAll.apply(env, arguments);
    },

    expect: function(actual) {
      return env.expect(actual);
    },

    pending: function() {
      return env.pending.apply(env, arguments);
    },

    fail: function() {
      return env.fail.apply(env, arguments);
    },

    spyOn: function(obj, methodName) {
      return env.spyOn(obj, methodName);
    },

    jsApiReporter: new jasmine.JsApiReporter({
      timer: new jasmine.Timer()
    }),

    jasmine: jasmine
  };

  jasmine.addCustomEqualityTester = function(tester) {
    env.addCustomEqualityTester(tester);
  };

  jasmine.addMatchers = function(matchers) {
    return env.addMatchers(matchers);
  };

  jasmine.clock = function() {
    return env.clock;
  };

  return jasmineInterface;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var jasmine = jasmineRequire.core(jasmineRequire);

var consoleFns = require(&#x27;../console/console.js&#x27;);
consoleFns.console(consoleFns, jasmine);

var env = jasmine.getEnv();

var jasmineInterface = jasmineRequire.<span class="apidocCodeKeywordSpan">interface</span>(jasmine, env);

extend(global, jasmineInterface);

function extend(destination, source) {
  for (var property in source) destination[property] = source[property];
  return destination;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.matchersUtil" id="apidoc.element.jasmine-core.matchersUtil">
        function <span class="apidocSignatureSpan">jasmine-core.</span>matchersUtil
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">matchersUtil = function (j$) {
  // TODO: what to do about jasmine.pp not being inject? move to JSON.stringify? gut PrettyPrinter?

  return {
    equals: function(a, b, customTesters) {
      customTesters = customTesters || [];

      return eq(a, b, [], [], customTesters);
    },

    contains: function(haystack, needle, customTesters) {
      customTesters = customTesters || [];

      if ((Object.prototype.toString.apply(haystack) === &#x27;[object Array]&#x27;) ||
        (!!haystack &#x26;&#x26; !haystack.indexOf))
      {
        for (var i = 0; i &#x3c; haystack.length; i++) {
          if (eq(haystack[i], needle, [], [], customTesters)) {
            return true;
          }
        }
        return false;
      }

      return !!haystack &#x26;&#x26; haystack.indexOf(needle) &#x3e;= 0;
    },

    buildFailureMessage: function() {
      var args = Array.prototype.slice.call(arguments, 0),
        matcherName = args[0],
        isNot = args[1],
        actual = args[2],
        expected = args.slice(3),
        englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return &#x27; &#x27; + s.toLowerCase(); });

      var message = &#x27;Expected &#x27; +
        j$.pp(actual) +
        (isNot ? &#x27; not &#x27; : &#x27; &#x27;) +
        englishyPredicate;

      if (expected.length &#x3e; 0) {
        for (var i = 0; i &#x3c; expected.length; i++) {
          if (i &#x3e; 0) {
            message += &#x27;,&#x27;;
          }
          message += &#x27; &#x27; + j$.pp(expected[i]);
        }
      }

      return message + &#x27;.&#x27;;
    }
  };

  function isAsymmetric(obj) {
    return obj &#x26;&#x26; j$.isA_(&#x27;Function&#x27;, obj.asymmetricMatch);
  }

  function asymmetricMatch(a, b) {
    var asymmetricA = isAsymmetric(a),
        asymmetricB = isAsymmetric(b);

    if (asymmetricA &#x26;&#x26; asymmetricB) {
      return undefined;
    }

    if (asymmetricA) {
      return a.asymmetricMatch(b);
    }

    if (asymmetricB) {
      return b.asymmetricMatch(a);
    }
  }

  // Equality function lovingly adapted from isEqual in
  //   [Underscore](http://underscorejs.org)
  function eq(a, b, aStack, bStack, customTesters) {
    var result = true;

    var asymmetricResult = asymmetricMatch(a, b);
    if (!j$.util.isUndefined(asymmetricResult)) {
      return asymmetricResult;
    }

    for (var i = 0; i &#x3c; customTesters.length; i++) {
      var customTesterResult = customTesters[i](a, b);
      if (!j$.util.isUndefined(customTesterResult)) {
        return customTesterResult;
      }
    }

    if (a instanceof Error &#x26;&#x26; b instanceof Error) {
      return a.message == b.message;
    }

    // Identical objects are equal. `0 === -0`, but they aren&#x27;t identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) { return a !== 0 || 1 / a == 1 / b; }
    // A strict comparison is necessary because `null == undefined`.
    if (a === null || b === null) { return a === b; }
    var className = Object.prototype.toString.call(a);
    if (className != Object.prototype.toString.call(b)) { return false; }
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case &#x27;[object String]&#x27;:
        // Primitives and their corresponding object wrappers are equivalent; thus, `&#x22;5&#x22;` is
        // equivalent to `new String(&#x22;5&#x22;)`.
        return a == String(b);
      case &#x27;[object Number]&#x27;:
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a === 0 ? 1 / a == 1 / b : a == +b);
      case &#x27;[object Date]&#x27;:
      case &#x27;[object Boolean]&#x27;:
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case &#x27;[object RegExp]&#x27;:
        return a.source == b.source &#x26;&#x26;
          a.global == b.global &#x26;&#x26;
          a.multiline == b.multiline &#x26;&#x26;
          a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != &#x27;object&#x27; || typeo ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.<span class="apidocCodeKeywordSpan">matchersUtil</span>(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.Spec(j$);
j$.SpyRegistry = jRequire.SpyRegistry(j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.pp" id="apidoc.element.jasmine-core.pp">
        function <span class="apidocSignatureSpan">jasmine-core.</span>pp
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pp = function (j$) {

  function PrettyPrinter() {
    this.ppNestLevel_ = 0;
    this.seen = [];
  }

  PrettyPrinter.prototype.format = function(value) {
    this.ppNestLevel_++;
    try {
      if (j$.util.isUndefined(value)) {
        this.emitScalar(&#x27;undefined&#x27;);
      } else if (value === null) {
        this.emitScalar(&#x27;null&#x27;);
      } else if (value === 0 &#x26;&#x26; 1/value === -Infinity) {
        this.emitScalar(&#x27;-0&#x27;);
      } else if (value === j$.getGlobal()) {
        this.emitScalar(&#x27;&#x3c;global&#x3e;&#x27;);
      } else if (value.jasmineToString) {
        this.emitScalar(value.jasmineToString());
      } else if (typeof value === &#x27;string&#x27;) {
        this.emitString(value);
      } else if (j$.isSpy(value)) {
        this.emitScalar(&#x27;spy on &#x27; + value.and.identity());
      } else if (value instanceof RegExp) {
        this.emitScalar(value.toString());
      } else if (typeof value === &#x27;function&#x27;) {
        this.emitScalar(&#x27;Function&#x27;);
      } else if (typeof value.nodeType === &#x27;number&#x27;) {
        this.emitScalar(&#x27;HTMLNode&#x27;);
      } else if (value instanceof Date) {
        this.emitScalar(&#x27;Date(&#x27; + value + &#x27;)&#x27;);
      } else if (value.toString &#x26;&#x26; typeof value === &#x27;object&#x27; &#x26;&#x26; !(value instanceof Array) &#x26;&#x26; value.toString !== Object.prototype
.toString) {
        this.emitScalar(value.toString());
      } else if (j$.util.arrayContains(this.seen, value)) {
        this.emitScalar(&#x27;&#x3c;circular reference: &#x27; + (j$.isArray_(value) ? &#x27;Array&#x27; : &#x27;Object&#x27;) + &#x27;&#x3e;&#x27;);
      } else if (j$.isArray_(value) || j$.isA_(&#x27;Object&#x27;, value)) {
        this.seen.push(value);
        if (j$.isArray_(value)) {
          this.emitArray(value);
        } else {
          this.emitObject(value);
        }
        this.seen.pop();
      } else {
        this.emitScalar(value.toString());
      }
    } finally {
      this.ppNestLevel_--;
    }
  };

  PrettyPrinter.prototype.iterateObject = function(obj, fn) {
    for (var property in obj) {
      if (!Object.prototype.hasOwnProperty.call(obj, property)) { continue; }
      fn(property, obj.__lookupGetter__ ? (!j$.util.isUndefined(obj.__lookupGetter__(property)) &#x26;&#x26;
          obj.__lookupGetter__(property) !== null) : false);
    }
  };

  PrettyPrinter.prototype.emitArray = j$.unimplementedMethod_;
  PrettyPrinter.prototype.emitObject = j$.unimplementedMethod_;
  PrettyPrinter.prototype.emitScalar = j$.unimplementedMethod_;
  PrettyPrinter.prototype.emitString = j$.unimplementedMethod_;

  function StringPrettyPrinter() {
    PrettyPrinter.call(this);

    this.string = &#x27;&#x27;;
  }

  j$.util.inherit(StringPrettyPrinter, PrettyPrinter);

  StringPrettyPrinter.prototype.emitScalar = function(value) {
    this.append(value);
  };

  StringPrettyPrinter.prototype.emitString = function(value) {
    this.append(&#x27;\&#x27;&#x27; + value + &#x27;\&#x27;&#x27;);
  };

  StringPrettyPrinter.prototype.emitArray = function(array) {
    if (this.ppNestLevel_ &#x3e; j$.MAX_PRETTY_PRINT_DEPTH) {
      this.append(&#x27;Array&#x27;);
      return;
    }
    var length = Math.min(array.length, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    this.append(&#x27;[ &#x27;);
    for (var i = 0; i &#x3c; length; i++) {
      if (i &#x3e; 0) {
        this.append(&#x27;, &#x27;);
      }
      this.format(array[i]);
    }
    if(array.length &#x3e; length){
      this.append(&#x27;, ...&#x27;);
    }

    var self = this;
    var first = array.length === 0;
    this.iterateObject(array, function(property, isGetter) {
      if (property.match(/^\d+$/)) {
        return;
      }

      if (first) {
        first = false;
      } else {
        self.append(&#x27;, &#x27;);
      }

      self.formatProperty(array, property, isGetter);
    });

    this.append(&#x27; ]&#x27;);
  };

  StringPrettyPrinter.prototype.emitObject = function(obj) {
    var constructorName = obj.constructor ? j$.fnNameFor(obj.constructor) : &#x27;null&#x27;;
    this.append(constructorName);

    if (this.ppNestLevel_ &#x3e; j$.MAX_PRETTY_PRINT_DEPTH) {
      return;
    }

    var self = this;
    this.append(&#x27;({ &#x27;);
    var first = true;

    this.iterateObject(obj, function(property, isGetter) {
      if (first) {
        first = false;
      } else {
        self.append(&#x27;, &#x27;);
      }

      s ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.<span class="apidocCodeKeywordSpan">pp</span>(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.Spec(j$);
j$.SpyRegistry = jRequire.SpyRegistry(j$);
j$.SpyStrategy = jRequire.SpyStrategy(j$);
j$.StringMatching = jRequire.StringMatching(j$);
j$.Suite = jRequire.Suite(j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.requireMatchers" id="apidoc.element.jasmine-core.requireMatchers">
        function <span class="apidocSignatureSpan">jasmine-core.</span>requireMatchers
        <span class="apidocSignatureSpan">(jRequire, j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">requireMatchers = function (jRequire, j$) {
  var availableMatchers = [
      &#x27;toBe&#x27;,
      &#x27;toBeCloseTo&#x27;,
      &#x27;toBeDefined&#x27;,
      &#x27;toBeFalsy&#x27;,
      &#x27;toBeGreaterThan&#x27;,
      &#x27;toBeGreaterThanOrEqual&#x27;,
      &#x27;toBeLessThanOrEqual&#x27;,
      &#x27;toBeLessThan&#x27;,
      &#x27;toBeNaN&#x27;,
      &#x27;toBeNull&#x27;,
      &#x27;toBeTruthy&#x27;,
      &#x27;toBeUndefined&#x27;,
      &#x27;toContain&#x27;,
      &#x27;toEqual&#x27;,
      &#x27;toHaveBeenCalled&#x27;,
      &#x27;toHaveBeenCalledWith&#x27;,
      &#x27;toHaveBeenCalledTimes&#x27;,
      &#x27;toMatch&#x27;,
      &#x27;toThrow&#x27;,
      &#x27;toThrowError&#x27;
    ],
    matchers = {};

  for (var i = 0; i &#x3c; availableMatchers.length; i++) {
    var name = availableMatchers[i];
    matchers[name] = jRequire[name](j$);
  }

  return matchers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    j$.StringMatching = jRequire.StringMatching(j$);
    j$.Suite = jRequire.Suite(j$);
    j$.Timer = jRequire.Timer();
    j$.TreeProcessor = jRequire.TreeProcessor();
    j$.version = jRequire.version();
    j$.Order = jRequire.Order();

    j$.matchers = jRequire.<span class="apidocCodeKeywordSpan">requireMatchers</span>(jRequire, j$);

    return j$;
  };

  return getJasmineRequire;
})(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.toBe" id="apidoc.element.jasmine-core.toBe">
        function <span class="apidocSignatureSpan">jasmine-core.</span>toBe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBe = function () {
  function toBe() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual === expected
        };
      }
    };
  }

  return toBe;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.toBeCloseTo" id="apidoc.element.jasmine-core.toBeCloseTo">
        function <span class="apidocSignatureSpan">jasmine-core.</span>toBeCloseTo
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBeCloseTo = function () {

  function toBeCloseTo() {
    return {
      compare: function(actual, expected, precision) {
        if (precision !== 0) {
          precision = precision || 2;
        }

        return {
          pass: Math.abs(expected - actual) &#x3c; (Math.pow(10, -precision) / 2)
        };
      }
    };
  }

  return toBeCloseTo;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.toBeDefined" id="apidoc.element.jasmine-core.toBeDefined">
        function <span class="apidocSignatureSpan">jasmine-core.</span>toBeDefined
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBeDefined = function () {
  function toBeDefined() {
    return {
      compare: function(actual) {
        return {
          pass: (void 0 !== actual)
        };
      }
    };
  }

  return toBeDefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.toBeFalsy" id="apidoc.element.jasmine-core.toBeFalsy">
        function <span class="apidocSignatureSpan">jasmine-core.</span>toBeFalsy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBeFalsy = function () {
  function toBeFalsy() {
    return {
      compare: function(actual) {
        return {
          pass: !!!actual
        };
      }
    };
  }

  return toBeFalsy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.toBeGreaterThan" id="apidoc.element.jasmine-core.toBeGreaterThan">
        function <span class="apidocSignatureSpan">jasmine-core.</span>toBeGreaterThan
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBeGreaterThan = function () {

  function toBeGreaterThan() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual &#x3e; expected
        };
      }
    };
  }

  return toBeGreaterThan;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.toBeGreaterThanOrEqual" id="apidoc.element.jasmine-core.toBeGreaterThanOrEqual">
        function <span class="apidocSignatureSpan">jasmine-core.</span>toBeGreaterThanOrEqual
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBeGreaterThanOrEqual = function () {

  function toBeGreaterThanOrEqual() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual &#x3e;= expected
        };
      }
    };
  }

  return toBeGreaterThanOrEqual;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.toBeLessThan" id="apidoc.element.jasmine-core.toBeLessThan">
        function <span class="apidocSignatureSpan">jasmine-core.</span>toBeLessThan
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBeLessThan = function () {
  function toBeLessThan() {
    return {

      compare: function(actual, expected) {
        return {
          pass: actual &#x3c; expected
        };
      }
    };
  }

  return toBeLessThan;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.toBeLessThanOrEqual" id="apidoc.element.jasmine-core.toBeLessThanOrEqual">
        function <span class="apidocSignatureSpan">jasmine-core.</span>toBeLessThanOrEqual
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBeLessThanOrEqual = function () {
  function toBeLessThanOrEqual() {
    return {

      compare: function(actual, expected) {
        return {
          pass: actual &#x3c;= expected
        };
      }
    };
  }

  return toBeLessThanOrEqual;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.toBeNaN" id="apidoc.element.jasmine-core.toBeNaN">
        function <span class="apidocSignatureSpan">jasmine-core.</span>toBeNaN
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBeNaN = function (j$) {

  function toBeNaN() {
    return {
      compare: function(actual) {
        var result = {
          pass: (actual !== actual)
        };

        if (result.pass) {
          result.message = &#x27;Expected actual not to be NaN.&#x27;;
        } else {
          result.message = function() { return &#x27;Expected &#x27; + j$.pp(actual) + &#x27; to be NaN.&#x27;; };
        }

        return result;
      }
    };
  }

  return toBeNaN;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.toBeNull" id="apidoc.element.jasmine-core.toBeNull">
        function <span class="apidocSignatureSpan">jasmine-core.</span>toBeNull
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBeNull = function () {

  function toBeNull() {
    return {
      compare: function(actual) {
        return {
          pass: actual === null
        };
      }
    };
  }

  return toBeNull;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.toBeTruthy" id="apidoc.element.jasmine-core.toBeTruthy">
        function <span class="apidocSignatureSpan">jasmine-core.</span>toBeTruthy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBeTruthy = function () {

  function toBeTruthy() {
    return {
      compare: function(actual) {
        return {
          pass: !!actual
        };
      }
    };
  }

  return toBeTruthy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.toBeUndefined" id="apidoc.element.jasmine-core.toBeUndefined">
        function <span class="apidocSignatureSpan">jasmine-core.</span>toBeUndefined
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBeUndefined = function () {

  function toBeUndefined() {
    return {
      compare: function(actual) {
        return {
          pass: void 0 === actual
        };
      }
    };
  }

  return toBeUndefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.toContain" id="apidoc.element.jasmine-core.toContain">
        function <span class="apidocSignatureSpan">jasmine-core.</span>toContain
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toContain = function () {
  function toContain(util, customEqualityTesters) {
    customEqualityTesters = customEqualityTesters || [];

    return {
      compare: function(actual, expected) {

        return {
          pass: util.contains(actual, expected, customEqualityTesters)
        };
      }
    };
  }

  return toContain;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.toEqual" id="apidoc.element.jasmine-core.toEqual">
        function <span class="apidocSignatureSpan">jasmine-core.</span>toEqual
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toEqual = function () {

  function toEqual(util, customEqualityTesters) {
    customEqualityTesters = customEqualityTesters || [];

    return {
      compare: function(actual, expected) {
        var result = {
          pass: false
        };

        result.pass = util.equals(actual, expected, customEqualityTesters);

        return result;
      }
    };
  }

  return toEqual;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.toHaveBeenCalled" id="apidoc.element.jasmine-core.toHaveBeenCalled">
        function <span class="apidocSignatureSpan">jasmine-core.</span>toHaveBeenCalled
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toHaveBeenCalled = function (j$) {

  var getErrorMsg = j$.formatErrorMsg(&#x27;&#x3c;toHaveBeenCalled&#x3e;&#x27;, &#x27;expect(&#x3c;spyObj&#x3e;).toHaveBeenCalled()&#x27;);

  function toHaveBeenCalled() {
    return {
      compare: function(actual) {
        var result = {};

        if (!j$.isSpy(actual)) {
          throw new Error(getErrorMsg(&#x27;Expected a spy, but got &#x27; + j$.pp(actual) + &#x27;.&#x27;));
        }

        if (arguments.length &#x3e; 1) {
          throw new Error(getErrorMsg(&#x27;Does not take arguments, use toHaveBeenCalledWith&#x27;));
        }

        result.pass = actual.calls.any();

        result.message = result.pass ?
          &#x27;Expected spy &#x27; + actual.and.identity() + &#x27; not to have been called.&#x27; :
          &#x27;Expected spy &#x27; + actual.and.identity() + &#x27; to have been called.&#x27;;

        return result;
      }
    };
  }

  return toHaveBeenCalled;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  return toEqual;
};

getJasmineRequireObj().toHaveBeenCalled = function(j$) {

  var getErrorMsg = j$.formatErrorMsg(&#x27;&#x3c;toHaveBeenCalled&#x3e;&#x27;, &#x27;expect(&#x3c;spyObj&#x3e;).<span class="apidocCodeKeywordSpan
">toHaveBeenCalled</span>()&#x27;);

  function toHaveBeenCalled() {
    return {
      compare: function(actual) {
var result = {};

if (!j$.isSpy(actual)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.toHaveBeenCalledTimes" id="apidoc.element.jasmine-core.toHaveBeenCalledTimes">
        function <span class="apidocSignatureSpan">jasmine-core.</span>toHaveBeenCalledTimes
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toHaveBeenCalledTimes = function (j$) {

  var getErrorMsg = j$.formatErrorMsg(&#x27;&#x3c;toHaveBeenCalledTimes&#x3e;&#x27;, &#x27;expect(&#x3c;spyObj&#x3e;).toHaveBeenCalledTimes(&#x3c;Number&#x3e;)&#x27;);

  function toHaveBeenCalledTimes() {
    return {
      compare: function(actual, expected) {
        if (!j$.isSpy(actual)) {
          throw new Error(getErrorMsg(&#x27;Expected a spy, but got &#x27; + j$.pp(actual) + &#x27;.&#x27;));
        }

        var args = Array.prototype.slice.call(arguments, 0),
          result = { pass: false };

        if (!j$.isNumber_(expected)){
          throw new Error(getErrorMsg(&#x27;The expected times failed is a required argument and must be a number.&#x27;));
        }

        actual = args[0];
        var calls = actual.calls.count();
        var timesMessage = expected === 1 ? &#x27;once&#x27; : expected + &#x27; times&#x27;;
        result.pass = calls === expected;
        result.message = result.pass ?
          &#x27;Expected spy &#x27; + actual.and.identity() + &#x27; not to have been called &#x27; + timesMessage + &#x27;. It was called &#x27; +  calls + &#x27;
times.&#x27; :
          &#x27;Expected spy &#x27; + actual.and.identity() + &#x27; to have been called &#x27; + timesMessage + &#x27;. It was called &#x27; +  calls + &#x27; times
.&#x27;;
        return result;
      }
    };
  }

  return toHaveBeenCalledTimes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

return toHaveBeenCalled;
};

getJasmineRequireObj().toHaveBeenCalledTimes = function(j$) {

var getErrorMsg = j$.formatErrorMsg(&#x27;&#x3c;toHaveBeenCalledTimes&#x3e;&#x27;, &#x27;expect(&#x3c;spyObj&#x3e;).<span class="
apidocCodeKeywordSpan">toHaveBeenCalledTimes</span>(&#x3c;Number&#x3e;)&#x27;);

function toHaveBeenCalledTimes() {
  return {
    compare: function(actual, expected) {
      if (!j$.isSpy(actual)) {
        throw new Error(getErrorMsg(&#x27;Expected a spy, but got &#x27; + j$.pp(actual) + &#x27;.&#x27;));
      }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.toHaveBeenCalledWith" id="apidoc.element.jasmine-core.toHaveBeenCalledWith">
        function <span class="apidocSignatureSpan">jasmine-core.</span>toHaveBeenCalledWith
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toHaveBeenCalledWith = function (j$) {

  var getErrorMsg = j$.formatErrorMsg(&#x27;&#x3c;toHaveBeenCalledWith&#x3e;&#x27;, &#x27;expect(&#x3c;spyObj&#x3e;).toHaveBeenCalledWith(...arguments)&#x27;);

  function toHaveBeenCalledWith(util, customEqualityTesters) {
    return {
      compare: function() {
        var args = Array.prototype.slice.call(arguments, 0),
          actual = args[0],
          expectedArgs = args.slice(1),
          result = { pass: false };

        if (!j$.isSpy(actual)) {
          throw new Error(getErrorMsg(&#x27;Expected a spy, but got &#x27; + j$.pp(actual) + &#x27;.&#x27;));
        }

        if (!actual.calls.any()) {
          result.message = function() { return &#x27;Expected spy &#x27; + actual.and.identity() + &#x27; to have been called with &#x27; + j$.pp(expectedArgs
) + &#x27; but it was never called.&#x27;; };
          return result;
        }

        if (util.contains(actual.calls.allArgs(), expectedArgs, customEqualityTesters)) {
          result.pass = true;
          result.message = function() { return &#x27;Expected spy &#x27; + actual.and.identity() + &#x27; not to have been called with &#x27; + j$.pp
(expectedArgs) + &#x27; but it was.&#x27;; };
        } else {
          result.message = function() { return &#x27;Expected spy &#x27; + actual.and.identity() + &#x27; to have been called with &#x27; + j$.pp(expectedArgs
) + &#x27; but actual calls were &#x27; + j$.pp(actual.calls.allArgs()).replace(/^\[ | \]$/g, &#x27;&#x27;) + &#x27;.&#x27;; };
        }

        return result;
      }
    };
  }

  return toHaveBeenCalledWith;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

return toHaveBeenCalledTimes;
};

getJasmineRequireObj().toHaveBeenCalledWith = function(j$) {

var getErrorMsg = j$.formatErrorMsg(&#x27;&#x3c;toHaveBeenCalledWith&#x3e;&#x27;, &#x27;expect(&#x3c;spyObj&#x3e;).<span class="
apidocCodeKeywordSpan">toHaveBeenCalledWith</span>(...arguments)&#x27;);

function toHaveBeenCalledWith(util, customEqualityTesters) {
  return {
    compare: function() {
      var args = Array.prototype.slice.call(arguments, 0),
        actual = args[0],
        expectedArgs = args.slice(1),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.toMatch" id="apidoc.element.jasmine-core.toMatch">
        function <span class="apidocSignatureSpan">jasmine-core.</span>toMatch
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toMatch = function (j$) {

  var getErrorMsg = j$.formatErrorMsg(&#x27;&#x3c;toMatch&#x3e;&#x27;, &#x27;expect(&#x3c;expectation&#x3e;).toMatch(&#x3c;string&#x3e; || &#x3c;regexp&#x3e;)&#x27;);

  function toMatch() {
    return {
      compare: function(actual, expected) {
        if (!j$.isString_(expected) &#x26;&#x26; !j$.isA_(&#x27;RegExp&#x27;, expected)) {
          throw new Error(getErrorMsg(&#x27;Expected is not a String or a RegExp&#x27;));
        }

        var regexp = new RegExp(expected);

        return {
          pass: regexp.test(actual)
        };
      }
    };
  }

  return toMatch;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

return toHaveBeenCalledWith;
};

getJasmineRequireObj().toMatch = function(j$) {

var getErrorMsg = j$.formatErrorMsg(&#x27;&#x3c;toMatch&#x3e;&#x27;, &#x27;expect(&#x3c;expectation&#x3e;).<span class="apidocCodeKeywordSpan
">toMatch</span>(&#x3c;string&#x3e; || &#x3c;regexp&#x3e;)&#x27;);

function toMatch() {
  return {
    compare: function(actual, expected) {
      if (!j$.isString_(expected) &#x26;&#x26; !j$.isA_(&#x27;RegExp&#x27;, expected)) {
        throw new Error(getErrorMsg(&#x27;Expected is not a String or a RegExp&#x27;));
      }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.toThrow" id="apidoc.element.jasmine-core.toThrow">
        function <span class="apidocSignatureSpan">jasmine-core.</span>toThrow
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toThrow = function (j$) {

  var getErrorMsg = j$.formatErrorMsg(&#x27;&#x3c;toThrow&#x3e;&#x27;, &#x27;expect(function() {&#x3c;expectation&#x3e;}).toThrow()&#x27;);

  function toThrow(util) {
    return {
      compare: function(actual, expected) {
        var result = { pass: false },
          threw = false,
          thrown;

        if (typeof actual != &#x27;function&#x27;) {
          throw new Error(getErrorMsg(&#x27;Actual is not a Function&#x27;));
        }

        try {
          actual();
        } catch (e) {
          threw = true;
          thrown = e;
        }

        if (!threw) {
          result.message = &#x27;Expected function to throw an exception.&#x27;;
          return result;
        }

        if (arguments.length == 1) {
          result.pass = true;
          result.message = function() { return &#x27;Expected function not to throw, but it threw &#x27; + j$.pp(thrown) + &#x27;.&#x27;; };

          return result;
        }

        if (util.equals(thrown, expected)) {
          result.pass = true;
          result.message = function() { return &#x27;Expected function not to throw &#x27; + j$.pp(expected) + &#x27;.&#x27;; };
        } else {
          result.message = function() { return &#x27;Expected function to throw &#x27; + j$.pp(expected) + &#x27;, but it threw &#x27; +  j$.pp(thrown
) + &#x27;.&#x27;; };
        }

        return result;
      }
    };
  }

  return toThrow;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

return toMatch;
};

getJasmineRequireObj().toThrow = function(j$) {

var getErrorMsg = j$.formatErrorMsg(&#x27;&#x3c;toThrow&#x3e;&#x27;, &#x27;expect(function() {&#x3c;expectation&#x3e;}).<span class
="apidocCodeKeywordSpan">toThrow</span>()&#x27;);

function toThrow(util) {
  return {
    compare: function(actual, expected) {
      var result = { pass: false },
        threw = false,
        thrown;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.toThrowError" id="apidoc.element.jasmine-core.toThrowError">
        function <span class="apidocSignatureSpan">jasmine-core.</span>toThrowError
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toThrowError = function (j$) {

  var getErrorMsg =  j$.formatErrorMsg(&#x27;&#x3c;toThrowError&#x3e;&#x27;, &#x27;expect(function() {&#x3c;expectation&#x3e;}).toThrowError(&#x3c;ErrorConstructor&#x3e;, &#x3c;message
&#x3e;)&#x27;);

  function toThrowError () {
    return {
      compare: function(actual) {
        var threw = false,
          pass = {pass: true},
          fail = {pass: false},
          thrown;

        if (typeof actual != &#x27;function&#x27;) {
          throw new Error(getErrorMsg(&#x27;Actual is not a Function&#x27;));
        }

        var errorMatcher = getMatcher.apply(null, arguments);

        try {
          actual();
        } catch (e) {
          threw = true;
          thrown = e;
        }

        if (!threw) {
          fail.message = &#x27;Expected function to throw an Error.&#x27;;
          return fail;
        }

        if (!(thrown instanceof Error)) {
          fail.message = function() { return &#x27;Expected function to throw an Error, but it threw &#x27; + j$.pp(thrown) + &#x27;.&#x27;; };
          return fail;
        }

        if (errorMatcher.hasNoSpecifics()) {
          pass.message = &#x27;Expected function not to throw an Error, but it threw &#x27; + j$.fnNameFor(thrown) + &#x27;.&#x27;;
          return pass;
        }

        if (errorMatcher.matches(thrown)) {
          pass.message = function() {
            return &#x27;Expected function not to throw &#x27; + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() + &#x27;.&#x27;;
          };
          return pass;
        } else {
          fail.message = function() {
            return &#x27;Expected function to throw &#x27; + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() +
              &#x27;, but it threw &#x27; + errorMatcher.thrownDescription(thrown) + &#x27;.&#x27;;
          };
          return fail;
        }
      }
    };

    function getMatcher() {
      var expected = null,
          errorType = null;

      if (arguments.length == 2) {
        expected = arguments[1];
        if (isAnErrorType(expected)) {
          errorType = expected;
          expected = null;
        }
      } else if (arguments.length &#x3e; 2) {
        errorType = arguments[1];
        expected = arguments[2];
        if (!isAnErrorType(errorType)) {
          throw new Error(getErrorMsg(&#x27;Expected error type is not an Error.&#x27;));
        }
      }

      if (expected &#x26;&#x26; !isStringOrRegExp(expected)) {
        if (errorType) {
          throw new Error(getErrorMsg(&#x27;Expected error message is not a string or RegExp.&#x27;));
        } else {
          throw new Error(getErrorMsg(&#x27;Expected is not an Error, string, or RegExp.&#x27;));
        }
      }

      function messageMatch(message) {
        if (typeof expected == &#x27;string&#x27;) {
          return expected == message;
        } else {
          return expected.test(message);
        }
      }

      return {
        errorTypeDescription: errorType ? j$.fnNameFor(errorType) : &#x27;an exception&#x27;,
        thrownDescription: function(thrown) {
          var thrownName = errorType ? j$.fnNameFor(thrown.constructor) : &#x27;an exception&#x27;,
              thrownMessage = &#x27;&#x27;;

          if (expected) {
            thrownMessage = &#x27; with message &#x27; + j$.pp(thrown.message);
          }

          return thrownName + thrownMessage;
        },
        messageDescription: function() {
          if (expected === null) {
            return &#x27;&#x27;;
          } else if (expected instanceof RegExp) {
            return &#x27; with a message matching &#x27; + j$.pp(expected);
          } else {
            return &#x27; with message &#x27; + j$.pp(expected);
          }
        },
        hasNoSpecifics: function() {
          return expected === null &#x26;&#x26; errorType === null;
        },
        matches: function(error) {
          return (errorType === null || error instanceof errorType) &#x26;&#x26;
            (expected === null || messageMatch(error.message));
        }
      };
    }

    function isStringOrRegExp(potential) {
      return potential instanceof RegExp || (typeof potential == &#x27;string&#x27;);
    }

    function isAnErrorType(type) {
      if (typeof type !== &#x27;function&#x27;) {
        return false;
      }

      var Surrogate = function() {};
      Surrogate.prototype = type.prototype;
      ret ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

return toThrow;
};

getJasmineRequireObj().toThrowError = function(j$) {

var getErrorMsg =  j$.formatErrorMsg(&#x27;&#x3c;toThrowError&#x3e;&#x27;, &#x27;expect(function() {&#x3c;expectation&#x3e;}).<span
 class="apidocCodeKeywordSpan">toThrowError</span>(&#x3c;ErrorConstructor&#x3e;, &#x3c;message&#x3e;)&#x27;);

function toThrowError () {
  return {
    compare: function(actual) {
      var threw = false,
        pass = {pass: true},
        fail = {pass: false},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.util" id="apidoc.element.jasmine-core.util">
        function <span class="apidocSignatureSpan">jasmine-core.</span>util
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">util = function () {

  var util = {};

  util.inherit = function(childClass, parentClass) {
    var Subclass = function() {
    };
    Subclass.prototype = parentClass.prototype;
    childClass.prototype = new Subclass();
  };

  util.htmlEscape = function(str) {
    if (!str) {
      return str;
    }
    return str.replace(/&#x26;/g, &#x27;&#x26;amp;&#x27;)
      .replace(/&#x3c;/g, &#x27;&#x26;lt;&#x27;)
      .replace(/&#x3e;/g, &#x27;&#x26;gt;&#x27;);
  };

  util.argsToArray = function(args) {
    var arrayOfArgs = [];
    for (var i = 0; i &#x3c; args.length; i++) {
      arrayOfArgs.push(args[i]);
    }
    return arrayOfArgs;
  };

  util.isUndefined = function(obj) {
    return obj === void 0;
  };

  util.arrayContains = function(array, search) {
    var i = array.length;
    while (i--) {
      if (array[i] === search) {
        return true;
      }
    }
    return false;
  };

  util.clone = function(obj) {
    if (Object.prototype.toString.apply(obj) === &#x27;[object Array]&#x27;) {
      return obj.slice();
    }

    var cloned = {};
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        cloned[prop] = obj[prop];
      }
    }

    return cloned;
  };

  return util;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return jasmineRequire;
  }

  getJasmineRequire().core = function(jRequire) {
var j$ = {};

jRequire.base(j$, jasmineGlobal);
j$.util = jRequire.<span class="apidocCodeKeywordSpan">util</span>();
j$.errors = jRequire.errors();
j$.formatErrorMsg = jRequire.formatErrorMsg();
j$.Any = jRequire.Any(j$);
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.version" id="apidoc.element.jasmine-core.version">
        function <span class="apidocSignatureSpan">jasmine-core.</span>version
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">version = function () {
  return &#x27;2.5.2&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  j$.Spec = jRequire.Spec(j$);
  j$.SpyRegistry = jRequire.SpyRegistry(j$);
  j$.SpyStrategy = jRequire.SpyStrategy(j$);
  j$.StringMatching = jRequire.StringMatching(j$);
  j$.Suite = jRequire.Suite(j$);
  j$.Timer = jRequire.Timer();
  j$.TreeProcessor = jRequire.TreeProcessor();
  j$.version = jRequire.<span class="apidocCodeKeywordSpan">version</span>();
  j$.Order = jRequire.Order();

  j$.matchers = jRequire.requireMatchers(jRequire, j$);

  return j$;
};
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jasmine-core.console" id="apidoc.module.jasmine-core.console">module jasmine-core.console</a></h1>


    <h2>
        <a href="#apidoc.element.jasmine-core.console.console" id="apidoc.element.jasmine-core.console.console">
        function <span class="apidocSignatureSpan">jasmine-core.</span>console
        <span class="apidocSignatureSpan">(jRequire, j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">console = function (jRequire, j$) {
  j$.ConsoleReporter = jRequire.ConsoleReporter();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
module.exports = function(jasmineRequire) {
var jasmine = jasmineRequire.core(jasmineRequire);

var consoleFns = require(&#x27;../console/console.js&#x27;);
consoleFns.<span class="apidocCodeKeywordSpan">console</span>(consoleFns, jasmine);

var env = jasmine.getEnv();

var jasmineInterface = jasmineRequire.interface(jasmine, env);

extend(global, jasmineInterface);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.console.ConsoleReporter" id="apidoc.element.jasmine-core.console.ConsoleReporter">
        function <span class="apidocSignatureSpan">jasmine-core.console.</span>ConsoleReporter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ConsoleReporter = function () {

  var noopTimer = {
    start: function(){},
    elapsed: function(){ return 0; }
  };

  function ConsoleReporter(options) {
    var print = options.print,
      showColors = options.showColors || false,
      onComplete = options.onComplete || function() {},
      timer = options.timer || noopTimer,
      specCount,
      failureCount,
      failedSpecs = [],
      pendingCount,
      ansi = {
        green: &#x27;\x1B[32m&#x27;,
        red: &#x27;\x1B[31m&#x27;,
        yellow: &#x27;\x1B[33m&#x27;,
        none: &#x27;\x1B[0m&#x27;
      },
      failedSuites = [];

    print(&#x27;ConsoleReporter is deprecated and will be removed in a future version.&#x27;);

    this.jasmineStarted = function() {
      specCount = 0;
      failureCount = 0;
      pendingCount = 0;
      print(&#x27;Started&#x27;);
      printNewline();
      timer.start();
    };

    this.jasmineDone = function() {
      printNewline();
      for (var i = 0; i &#x3c; failedSpecs.length; i++) {
        specFailureDetails(failedSpecs[i]);
      }

      if(specCount &#x3e; 0) {
        printNewline();

        var specCounts = specCount + &#x27; &#x27; + plural(&#x27;spec&#x27;, specCount) + &#x27;, &#x27; +
          failureCount + &#x27; &#x27; + plural(&#x27;failure&#x27;, failureCount);

        if (pendingCount) {
          specCounts += &#x27;, &#x27; + pendingCount + &#x27; pending &#x27; + plural(&#x27;spec&#x27;, pendingCount);
        }

        print(specCounts);
      } else {
        print(&#x27;No specs found&#x27;);
      }

      printNewline();
      var seconds = timer.elapsed() / 1000;
      print(&#x27;Finished in &#x27; + seconds + &#x27; &#x27; + plural(&#x27;second&#x27;, seconds));
      printNewline();

      for(i = 0; i &#x3c; failedSuites.length; i++) {
        suiteFailureDetails(failedSuites[i]);
      }

      onComplete(failureCount === 0);
    };

    this.specDone = function(result) {
      specCount++;

      if (result.status == &#x27;pending&#x27;) {
        pendingCount++;
        print(colored(&#x27;yellow&#x27;, &#x27;*&#x27;));
        return;
      }

      if (result.status == &#x27;passed&#x27;) {
        print(colored(&#x27;green&#x27;, &#x27;.&#x27;));
        return;
      }

      if (result.status == &#x27;failed&#x27;) {
        failureCount++;
        failedSpecs.push(result);
        print(colored(&#x27;red&#x27;, &#x27;F&#x27;));
      }
    };

    this.suiteDone = function(result) {
      if (result.failedExpectations &#x26;&#x26; result.failedExpectations.length &#x3e; 0) {
        failureCount++;
        failedSuites.push(result);
      }
    };

    return this;

    function printNewline() {
      print(&#x27;\n&#x27;);
    }

    function colored(color, str) {
      return showColors ? (ansi[color] + str + ansi.none) : str;
    }

    function plural(str, count) {
      return count == 1 ? str : str + &#x27;s&#x27;;
    }

    function repeat(thing, times) {
      var arr = [];
      for (var i = 0; i &#x3c; times; i++) {
        arr.push(thing);
      }
      return arr;
    }

    function indent(str, spaces) {
      var lines = (str || &#x27;&#x27;).split(&#x27;\n&#x27;);
      var newArr = [];
      for (var i = 0; i &#x3c; lines.length; i++) {
        newArr.push(repeat(&#x27; &#x27;, spaces).join(&#x27;&#x27;) + lines[i]);
      }
      return newArr.join(&#x27;\n&#x27;);
    }

    function specFailureDetails(result) {
      printNewline();
      print(result.fullName);

      for (var i = 0; i &#x3c; result.failedExpectations.length; i++) {
        var failedExpectation = result.failedExpectations[i];
        printNewline();
        print(indent(failedExpectation.message, 2));
        print(indent(failedExpectation.stack, 2));
      }

      printNewline();
    }

    function suiteFailureDetails(result) {
      for (var i = 0; i &#x3c; result.failedExpectations.length; i++) {
        printNewline();
        print(colored(&#x27;red&#x27;, &#x27;An error was thrown in an afterAll&#x27;));
        printNewline();
        print(colored(&#x27;red&#x27;, &#x27;AfterAll &#x27; + result.failedExpectations[i].message));

      }
      printNewline();
    }
  }

  return ConsoleReporter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  window.jasmineRequire = window.jasmineRequire || {};
  return window.jasmineRequire;
}
}

getJasmineRequireObj().console = function(jRequire, j$) {
j$.ConsoleReporter = jRequire.<span class="apidocCodeKeywordSpan">ConsoleReporter</span>();
};

getJasmineRequireObj().ConsoleReporter = function() {

var noopTimer = {
  start: function(){},
  elapsed: function(){ return 0; }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jasmine-core.jasmine" id="apidoc.module.jasmine-core.jasmine">module jasmine-core.jasmine</a></h1>


    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.Any" id="apidoc.element.jasmine-core.jasmine.Any">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>Any
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Any = function (j$) {

  function Any(expectedObject) {
    if (typeof expectedObject === &#x27;undefined&#x27;) {
      throw new TypeError(
        &#x27;jasmine.any() expects to be passed a constructor function. &#x27; +
        &#x27;Please pass one or use jasmine.anything() to match any object.&#x27;
      );
    }
    this.expectedObject = expectedObject;
  }

  Any.prototype.asymmetricMatch = function(other) {
    if (this.expectedObject == String) {
      return typeof other == &#x27;string&#x27; || other instanceof String;
    }

    if (this.expectedObject == Number) {
      return typeof other == &#x27;number&#x27; || other instanceof Number;
    }

    if (this.expectedObject == Function) {
      return typeof other == &#x27;function&#x27; || other instanceof Function;
    }

    if (this.expectedObject == Object) {
      return typeof other == &#x27;object&#x27;;
    }

    if (this.expectedObject == Boolean) {
      return typeof other == &#x27;boolean&#x27;;
    }

    return other instanceof this.expectedObject;
  };

  Any.prototype.jasmineToString = function() {
    return &#x27;&#x3c;jasmine.any(&#x27; + j$.fnNameFor(this.expectedObject) + &#x27;)&#x3e;&#x27;;
  };

  return Any;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  getJasmineRequire().core = function(jRequire) {
var j$ = {};

jRequire.base(j$, jasmineGlobal);
j$.util = jRequire.util();
j$.errors = jRequire.errors();
j$.formatErrorMsg = jRequire.formatErrorMsg();
j$.Any = jRequire.<span class="apidocCodeKeywordSpan">Any</span>(j$);
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.Anything" id="apidoc.element.jasmine-core.jasmine.Anything">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>Anything
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Anything = function (j$) {

  function Anything() {}

  Anything.prototype.asymmetricMatch = function(other) {
    return !j$.util.isUndefined(other) &#x26;&#x26; other !== null;
  };

  Anything.prototype.jasmineToString = function() {
    return &#x27;&#x3c;jasmine.anything&#x3e;&#x27;;
  };

  return Anything;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var j$ = {};

jRequire.base(j$, jasmineGlobal);
j$.util = jRequire.util();
j$.errors = jRequire.errors();
j$.formatErrorMsg = jRequire.formatErrorMsg();
j$.Any = jRequire.Any(j$);
j$.Anything = jRequire.<span class="apidocCodeKeywordSpan">Anything</span>(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.ArrayContaining" id="apidoc.element.jasmine-core.jasmine.ArrayContaining">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>ArrayContaining
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ArrayContaining = function (j$) {
  function ArrayContaining(sample) {
    this.sample = sample;
  }

  ArrayContaining.prototype.asymmetricMatch = function(other) {
    var className = Object.prototype.toString.call(this.sample);
    if (className !== &#x27;[object Array]&#x27;) { throw new Error(&#x27;You must provide an array to arrayContaining, not \&#x27;&#x27; + this.sample + &#x27;\&#x27;.&#x27;); }

    for (var i = 0; i &#x3c; this.sample.length; i++) {
      var item = this.sample[i];
      if (!j$.matchersUtil.contains(other, item)) {
        return false;
      }
    }

    return true;
  };

  ArrayContaining.prototype.jasmineToString = function () {
    return &#x27;&#x3c;jasmine.arrayContaining(&#x27; + jasmine.pp(this.sample) +&#x27;)&#x3e;&#x27;;
  };

  return ArrayContaining;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.<span class="apidocCodeKeywordSpan">ArrayContaining</span>(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.Spec(j$);
j$.SpyRegistry = jRequire.SpyRegistry(j$);
j$.SpyStrategy = jRequire.SpyStrategy(j$);
j$.StringMatching = jRequire.StringMatching(j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.CallTracker" id="apidoc.element.jasmine-core.jasmine.CallTracker">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>CallTracker
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CallTracker = function (j$) {

  function CallTracker() {
    var calls = [];
    var opts = {};

    function argCloner(context) {
      var clonedArgs = [];
      var argsAsArray = j$.util.argsToArray(context.args);
      for(var i = 0; i &#x3c; argsAsArray.length; i++) {
        if(Object.prototype.toString.apply(argsAsArray[i]).match(/^\[object/)) {
          clonedArgs.push(j$.util.clone(argsAsArray[i]));
        } else {
          clonedArgs.push(argsAsArray[i]);
        }
      }
      context.args = clonedArgs;
    }

    this.track = function(context) {
      if(opts.cloneArgs) {
        argCloner(context);
      }
      calls.push(context);
    };

    this.any = function() {
      return !!calls.length;
    };

    this.count = function() {
      return calls.length;
    };

    this.argsFor = function(index) {
      var call = calls[index];
      return call ? call.args : [];
    };

    this.all = function() {
      return calls;
    };

    this.allArgs = function() {
      var callArgs = [];
      for(var i = 0; i &#x3c; calls.length; i++){
        callArgs.push(calls[i].args);
      }

      return callArgs;
    };

    this.first = function() {
      return calls[0];
    };

    this.mostRecent = function() {
      return calls[calls.length - 1];
    };

    this.reset = function() {
      calls = [];
    };

    this.saveArgumentsByValue = function() {
      opts.cloneArgs = true;
    };

  }

  return CallTracker;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

jRequire.base(j$, jasmineGlobal);
j$.util = jRequire.util();
j$.errors = jRequire.errors();
j$.formatErrorMsg = jRequire.formatErrorMsg();
j$.Any = jRequire.Any(j$);
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.<span class="apidocCodeKeywordSpan">CallTracker</span>(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.Clock" id="apidoc.element.jasmine-core.jasmine.Clock">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>Clock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Clock = function () {
  function Clock(global, delayedFunctionSchedulerFactory, mockDate) {
    var self = this,
      realTimingFunctions = {
        setTimeout: global.setTimeout,
        clearTimeout: global.clearTimeout,
        setInterval: global.setInterval,
        clearInterval: global.clearInterval
      },
      fakeTimingFunctions = {
        setTimeout: setTimeout,
        clearTimeout: clearTimeout,
        setInterval: setInterval,
        clearInterval: clearInterval
      },
      installed = false,
      delayedFunctionScheduler,
      timer;


    self.install = function() {
      if(!originalTimingFunctionsIntact()) {
        throw new Error(&#x27;Jasmine Clock was unable to install over custom global timer functions. Is the clock already installed?&#x27;);
      }
      replace(global, fakeTimingFunctions);
      timer = fakeTimingFunctions;
      delayedFunctionScheduler = delayedFunctionSchedulerFactory();
      installed = true;

      return self;
    };

    self.uninstall = function() {
      delayedFunctionScheduler = null;
      mockDate.uninstall();
      replace(global, realTimingFunctions);

      timer = realTimingFunctions;
      installed = false;
    };

    self.withMock = function(closure) {
      this.install();
      try {
        closure();
      } finally {
        this.uninstall();
      }
    };

    self.mockDate = function(initialDate) {
      mockDate.install(initialDate);
    };

    self.setTimeout = function(fn, delay, params) {
      if (legacyIE()) {
        if (arguments.length &#x3e; 2) {
          throw new Error(&#x27;IE &#x3c; 9 cannot support extra params to setTimeout without a polyfill&#x27;);
        }
        return timer.setTimeout(fn, delay);
      }
      return Function.prototype.apply.apply(timer.setTimeout, [global, arguments]);
    };

    self.setInterval = function(fn, delay, params) {
      if (legacyIE()) {
        if (arguments.length &#x3e; 2) {
          throw new Error(&#x27;IE &#x3c; 9 cannot support extra params to setInterval without a polyfill&#x27;);
        }
        return timer.setInterval(fn, delay);
      }
      return Function.prototype.apply.apply(timer.setInterval, [global, arguments]);
    };

    self.clearTimeout = function(id) {
      return Function.prototype.call.apply(timer.clearTimeout, [global, id]);
    };

    self.clearInterval = function(id) {
      return Function.prototype.call.apply(timer.clearInterval, [global, id]);
    };

    self.tick = function(millis) {
      if (installed) {
        delayedFunctionScheduler.tick(millis, function(millis) { mockDate.tick(millis); });
      } else {
        throw new Error(&#x27;Mock clock is not installed, use jasmine.clock().install()&#x27;);
      }
    };

    return self;

    function originalTimingFunctionsIntact() {
      return global.setTimeout === realTimingFunctions.setTimeout &#x26;&#x26;
        global.clearTimeout === realTimingFunctions.clearTimeout &#x26;&#x26;
        global.setInterval === realTimingFunctions.setInterval &#x26;&#x26;
        global.clearInterval === realTimingFunctions.clearInterval;
    }

    function legacyIE() {
      //if these methods are polyfilled, apply will be present
      return !(realTimingFunctions.setTimeout || realTimingFunctions.setInterval).apply;
    }

    function replace(dest, source) {
      for (var prop in source) {
        dest[prop] = source[prop];
      }
    }

    function setTimeout(fn, delay) {
      return delayedFunctionScheduler.scheduleFunction(fn, delay, argSlice(arguments, 2));
    }

    function clearTimeout(id) {
      return delayedFunctionScheduler.removeFunctionWithId(id);
    }

    function setInterval(fn, interval) {
      return delayedFunctionScheduler.scheduleFunction(fn, interval, argSlice(arguments, 2), true);
    }

    function clearInterval(id) {
      return delayedFunctionScheduler.removeFunctionWithId(id);
    }

    function argSlice(argsObj, n) {
      return Array.prototype.slice.call(argsObj, n);
    }
  }

  return Clock;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.util = jRequire.util();
j$.errors = jRequire.errors();
j$.formatErrorMsg = jRequire.formatErrorMsg();
j$.Any = jRequire.Any(j$);
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.<span class="apidocCodeKeywordSpan">Clock</span>();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.DelayedFunctionScheduler" id="apidoc.element.jasmine-core.jasmine.DelayedFunctionScheduler">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>DelayedFunctionScheduler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DelayedFunctionScheduler = function () {
  function DelayedFunctionScheduler() {
    var self = this;
    var scheduledLookup = [];
    var scheduledFunctions = {};
    var currentTime = 0;
    var delayedFnCount = 0;

    self.tick = function(millis, tickDate) {
      millis = millis || 0;
      var endTime = currentTime + millis;

      runScheduledFunctions(endTime, tickDate);
      currentTime = endTime;
    };

    self.scheduleFunction = function(funcToCall, millis, params, recurring, timeoutKey, runAtMillis) {
      var f;
      if (typeof(funcToCall) === &#x27;string&#x27;) {
<span class="apidocCodeCommentSpan">        /* jshint evil: true */
</span>        f = function() { return eval(funcToCall); };
        /* jshint evil: false */
      } else {
        f = funcToCall;
      }

      millis = millis || 0;
      timeoutKey = timeoutKey || ++delayedFnCount;
      runAtMillis = runAtMillis || (currentTime + millis);

      var funcToSchedule = {
        runAtMillis: runAtMillis,
        funcToCall: f,
        recurring: recurring,
        params: params,
        timeoutKey: timeoutKey,
        millis: millis
      };

      if (runAtMillis in scheduledFunctions) {
        scheduledFunctions[runAtMillis].push(funcToSchedule);
      } else {
        scheduledFunctions[runAtMillis] = [funcToSchedule];
        scheduledLookup.push(runAtMillis);
        scheduledLookup.sort(function (a, b) {
          return a - b;
        });
      }

      return timeoutKey;
    };

    self.removeFunctionWithId = function(timeoutKey) {
      for (var runAtMillis in scheduledFunctions) {
        var funcs = scheduledFunctions[runAtMillis];
        var i = indexOfFirstToPass(funcs, function (func) {
          return func.timeoutKey === timeoutKey;
        });

        if (i &#x3e; -1) {
          if (funcs.length === 1) {
            delete scheduledFunctions[runAtMillis];
            deleteFromLookup(runAtMillis);
          } else {
            funcs.splice(i, 1);
          }

          // intervals get rescheduled when executed, so there&#x27;s never more
          // than a single scheduled function with a given timeoutKey
          break;
        }
      }
    };

    return self;

    function indexOfFirstToPass(array, testFn) {
      var index = -1;

      for (var i = 0; i &#x3c; array.length; ++i) {
        if (testFn(array[i])) {
          index = i;
          break;
        }
      }

      return index;
    }

    function deleteFromLookup(key) {
      var value = Number(key);
      var i = indexOfFirstToPass(scheduledLookup, function (millis) {
        return millis === value;
      });

      if (i &#x3e; -1) {
        scheduledLookup.splice(i, 1);
      }
    }

    function reschedule(scheduledFn) {
      self.scheduleFunction(scheduledFn.funcToCall,
        scheduledFn.millis,
        scheduledFn.params,
        true,
        scheduledFn.timeoutKey,
        scheduledFn.runAtMillis + scheduledFn.millis);
    }

    function forEachFunction(funcsToRun, callback) {
      for (var i = 0; i &#x3c; funcsToRun.length; ++i) {
        callback(funcsToRun[i]);
      }
    }

    function runScheduledFunctions(endTime, tickDate) {
      tickDate = tickDate || function() {};
      if (scheduledLookup.length === 0 || scheduledLookup[0] &#x3e; endTime) {
        tickDate(endTime - currentTime);
        return;
      }

      do {
        var newCurrentTime = scheduledLookup.shift();
        tickDate(newCurrentTime - currentTime);

        currentTime = newCurrentTime;

        var funcsToRun = scheduledFunctions[currentTime];
        delete scheduledFunctions[currentTime];

        forEachFunction(funcsToRun, function(funcToRun) {
          if (funcToRun.recurring) {
            reschedule(funcToRun);
          }
        });

        forEachFunction(funcsToRun, function(funcToRun) {
          funcToRun.funcToCall.apply(null, funcToRun.params || []);
        });
      } while (scheduledLookup.length &#x3e; 0 &#x26;&#x26;
              // checking first if we&#x27;re out of time prevents setTimeout(0)
              // scheduled in a funcToRun from forcing an extra iteration
                 currentTime !== endTime  &#x26;&#x26;
                 scheduledLookup[0] &#x3c;= endT ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.errors = jRequire.errors();
j$.formatErrorMsg = jRequire.formatErrorMsg();
j$.Any = jRequire.Any(j$);
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.<span class="apidocCodeKeywordSpan">DelayedFunctionScheduler</span>();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.Env" id="apidoc.element.jasmine-core.jasmine.Env">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>Env
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Env = function (j$) {
  function Env(options) {
    options = options || {};

    var self = this;
    var global = options.global || j$.getGlobal();

    var totalSpecsDefined = 0;

    var catchExceptions = true;

    var realSetTimeout = j$.getGlobal().setTimeout;
    var realClearTimeout = j$.getGlobal().clearTimeout;
    this.clock = new j$.Clock(global, function () { return new j$.DelayedFunctionScheduler(); }, new j$.MockDate(global));

    var runnableResources = {};

    var currentSpec = null;
    var currentlyExecutingSuites = [];
    var currentDeclarationSuite = null;
    var throwOnExpectationFailure = false;
    var random = false;
    var seed = null;

    var currentSuite = function() {
      return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];
    };

    var currentRunnable = function() {
      return currentSpec || currentSuite();
    };

    var reporter = new j$.ReportDispatcher([
      &#x27;jasmineStarted&#x27;,
      &#x27;jasmineDone&#x27;,
      &#x27;suiteStarted&#x27;,
      &#x27;suiteDone&#x27;,
      &#x27;specStarted&#x27;,
      &#x27;specDone&#x27;
    ]);

    this.specFilter = function() {
      return true;
    };

    this.addCustomEqualityTester = function(tester) {
      if(!currentRunnable()) {
        throw new Error(&#x27;Custom Equalities must be added in a before function or a spec&#x27;);
      }
      runnableResources[currentRunnable().id].customEqualityTesters.push(tester);
    };

    this.addMatchers = function(matchersToAdd) {
      if(!currentRunnable()) {
        throw new Error(&#x27;Matchers must be added in a before function or a spec&#x27;);
      }
      var customMatchers = runnableResources[currentRunnable().id].customMatchers;
      for (var matcherName in matchersToAdd) {
        customMatchers[matcherName] = matchersToAdd[matcherName];
      }
    };

    j$.Expectation.addCoreMatchers(j$.matchers);

    var nextSpecId = 0;
    var getNextSpecId = function() {
      return &#x27;spec&#x27; + nextSpecId++;
    };

    var nextSuiteId = 0;
    var getNextSuiteId = function() {
      return &#x27;suite&#x27; + nextSuiteId++;
    };

    var expectationFactory = function(actual, spec) {
      return j$.Expectation.Factory({
        util: j$.matchersUtil,
        customEqualityTesters: runnableResources[spec.id].customEqualityTesters,
        customMatchers: runnableResources[spec.id].customMatchers,
        actual: actual,
        addExpectationResult: addExpectationResult
      });

      function addExpectationResult(passed, result) {
        return spec.addExpectationResult(passed, result);
      }
    };

    var defaultResourcesForRunnable = function(id, parentRunnableId) {
      var resources = {spies: [], customEqualityTesters: [], customMatchers: {}};

      if(runnableResources[parentRunnableId]){
        resources.customEqualityTesters = j$.util.clone(runnableResources[parentRunnableId].customEqualityTesters);
        resources.customMatchers = j$.util.clone(runnableResources[parentRunnableId].customMatchers);
      }

      runnableResources[id] = resources;
    };

    var clearResourcesForRunnable = function(id) {
        spyRegistry.clearSpies();
        delete runnableResources[id];
    };

    var beforeAndAfterFns = function(suite) {
      return function() {
        var befores = [],
          afters = [];

        while(suite) {
          befores = befores.concat(suite.beforeFns);
          afters = afters.concat(suite.afterFns);

          suite = suite.parentSuite;
        }

        return {
          befores: befores.reverse(),
          afters: afters
        };
      };
    };

    var getSpecName = function(spec, suite) {
      var fullName = [spec.description],
          suiteFullName = suite.getFullName();

      if (suiteFullName !== &#x27;&#x27;) {
        fullName.unshift(suiteFullName);
      }
      return fullName.join(&#x27; &#x27;);
    };

    // TODO: we may just be able to pass in the fn instead of wrapping here
    var buildExpectationResult = j$.buildExpectationResult,
        exceptionFormatter = new j$.ExceptionFormatter(),
        expectationResultFactory = function(attrs) {
          attrs.messageFormatter = exceptionFormat ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.formatErrorMsg = jRequire.formatErrorMsg();
j$.Any = jRequire.Any(j$);
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.<span class="apidocCodeKeywordSpan">Env</span>(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.ExceptionFormatter" id="apidoc.element.jasmine-core.jasmine.ExceptionFormatter">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>ExceptionFormatter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ExceptionFormatter = function () {
  function ExceptionFormatter() {
    this.message = function(error) {
      var message = &#x27;&#x27;;

      if (error.name &#x26;&#x26; error.message) {
        message += error.name + &#x27;: &#x27; + error.message;
      } else {
        message += error.toString() + &#x27; thrown&#x27;;
      }

      if (error.fileName || error.sourceURL) {
        message += &#x27; in &#x27; + (error.fileName || error.sourceURL);
      }

      if (error.line || error.lineNumber) {
        message += &#x27; (line &#x27; + (error.line || error.lineNumber) + &#x27;)&#x27;;
      }

      return message;
    };

    this.stack = function(error) {
      return error ? error.stack : null;
    };
  }

  return ExceptionFormatter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.Any = jRequire.Any(j$);
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.<span class="apidocCodeKeywordSpan">ExceptionFormatter</span>();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.Expectation" id="apidoc.element.jasmine-core.jasmine.Expectation">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>Expectation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Expectation = function () {

  function Expectation(options) {
    this.util = options.util || { buildFailureMessage: function() {} };
    this.customEqualityTesters = options.customEqualityTesters || [];
    this.actual = options.actual;
    this.addExpectationResult = options.addExpectationResult || function(){};
    this.isNot = options.isNot;

    var customMatchers = options.customMatchers || {};
    for (var matcherName in customMatchers) {
      this[matcherName] = Expectation.prototype.wrapCompare(matcherName, customMatchers[matcherName]);
    }
  }

  Expectation.prototype.wrapCompare = function(name, matcherFactory) {
    return function() {
      var args = Array.prototype.slice.call(arguments, 0),
        expected = args.slice(0),
        message = &#x27;&#x27;;

      args.unshift(this.actual);

      var matcher = matcherFactory(this.util, this.customEqualityTesters),
          matcherCompare = matcher.compare;

      function defaultNegativeCompare() {
        var result = matcher.compare.apply(null, args);
        result.pass = !result.pass;
        return result;
      }

      if (this.isNot) {
        matcherCompare = matcher.negativeCompare || defaultNegativeCompare;
      }

      var result = matcherCompare.apply(null, args);

      if (!result.pass) {
        if (!result.message) {
          args.unshift(this.isNot);
          args.unshift(name);
          message = this.util.buildFailureMessage.apply(null, args);
        } else {
          if (Object.prototype.toString.apply(result.message) === &#x27;[object Function]&#x27;) {
            message = result.message();
          } else {
            message = result.message;
          }
        }
      }

      if (expected.length == 1) {
        expected = expected[0];
      }

      // TODO: how many of these params are needed?
      this.addExpectationResult(
        result.pass,
        {
          matcherName: name,
          passed: result.pass,
          message: message,
          actual: this.actual,
          expected: expected // TODO: this may need to be arrayified/sliced
        }
      );
    };
  };

  Expectation.addCoreMatchers = function(matchers) {
    var prototype = Expectation.prototype;
    for (var matcherName in matchers) {
      var matcher = matchers[matcherName];
      prototype[matcherName] = prototype.wrapCompare(matcherName, matcher);
    }
  };

  Expectation.Factory = function(options) {
    options = options || {};

    var expect = new Expectation(options);

    // TODO: this would be nice as its own Object - NegativeExpectation
    // TODO: copy instead of mutate options
    options.isNot = true;
    expect.not = new Expectation(options);

    return expect;
  };

  return Expectation;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.<span class="apidocCodeKeywordSpan">Expectation</span>();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.JsApiReporter" id="apidoc.element.jasmine-core.jasmine.JsApiReporter">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>JsApiReporter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JsApiReporter = function () {

  var noopTimer = {
    start: function(){},
    elapsed: function(){ return 0; }
  };

  function JsApiReporter(options) {
    var timer = options.timer || noopTimer,
        status = &#x27;loaded&#x27;;

    this.started = false;
    this.finished = false;
    this.runDetails = {};

    this.jasmineStarted = function() {
      this.started = true;
      status = &#x27;started&#x27;;
      timer.start();
    };

    var executionTime;

    this.jasmineDone = function(runDetails) {
      this.finished = true;
      this.runDetails = runDetails;
      executionTime = timer.elapsed();
      status = &#x27;done&#x27;;
    };

    this.status = function() {
      return status;
    };

    var suites = [],
      suites_hash = {};

    this.suiteStarted = function(result) {
      suites_hash[result.id] = result;
    };

    this.suiteDone = function(result) {
      storeSuite(result);
    };

    this.suiteResults = function(index, length) {
      return suites.slice(index, index + length);
    };

    function storeSuite(result) {
      suites.push(result);
      suites_hash[result.id] = result;
    }

    this.suites = function() {
      return suites_hash;
    };

    var specs = [];

    this.specDone = function(result) {
      specs.push(result);
    };

    this.specResults = function(index, length) {
      return specs.slice(index, index + length);
    };

    this.specs = function() {
      return specs;
    };

    this.executionTime = function() {
      return executionTime;
    };

  }

  return JsApiReporter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.<span class="apidocCodeKeywordSpan">JsApiReporter</span>();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.Spec(j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.MockDate" id="apidoc.element.jasmine-core.jasmine.MockDate">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>MockDate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MockDate = function () {
  function MockDate(global) {
    var self = this;
    var currentTime = 0;

    if (!global || !global.Date) {
      self.install = function() {};
      self.tick = function() {};
      self.uninstall = function() {};
      return self;
    }

    var GlobalDate = global.Date;

    self.install = function(mockDate) {
      if (mockDate instanceof GlobalDate) {
        currentTime = mockDate.getTime();
      } else {
        currentTime = new GlobalDate().getTime();
      }

      global.Date = FakeDate;
    };

    self.tick = function(millis) {
      millis = millis || 0;
      currentTime = currentTime + millis;
    };

    self.uninstall = function() {
      currentTime = 0;
      global.Date = GlobalDate;
    };

    createDateProperties();

    return self;

    function FakeDate() {
      switch(arguments.length) {
        case 0:
          return new GlobalDate(currentTime);
        case 1:
          return new GlobalDate(arguments[0]);
        case 2:
          return new GlobalDate(arguments[0], arguments[1]);
        case 3:
          return new GlobalDate(arguments[0], arguments[1], arguments[2]);
        case 4:
          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3]);
        case 5:
          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],
                                arguments[4]);
        case 6:
          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],
                                arguments[4], arguments[5]);
        default:
          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],
                                arguments[4], arguments[5], arguments[6]);
      }
    }

    function createDateProperties() {
      FakeDate.prototype = GlobalDate.prototype;

      FakeDate.now = function() {
        if (GlobalDate.now) {
          return currentTime;
        } else {
          throw new Error(&#x27;Browser does not support Date.now()&#x27;);
        }
      };

      FakeDate.toSource = GlobalDate.toSource;
      FakeDate.toString = GlobalDate.toString;
      FakeDate.parse = GlobalDate.parse;
      FakeDate.UTC = GlobalDate.UTC;
    }
	}

  return MockDate;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
jRequire.base(j$, jasmineGlobal);
j$.util = jRequire.util();
j$.errors = jRequire.errors();
j$.formatErrorMsg = jRequire.formatErrorMsg();
j$.Any = jRequire.Any(j$);
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.<span class="apidocCodeKeywordSpan">MockDate</span>();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.ObjectContaining" id="apidoc.element.jasmine-core.jasmine.ObjectContaining">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>ObjectContaining
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ObjectContaining = function (j$) {

  function ObjectContaining(sample) {
    this.sample = sample;
  }

  function getPrototype(obj) {
    if (Object.getPrototypeOf) {
      return Object.getPrototypeOf(obj);
    }

    if (obj.constructor.prototype == obj) {
      return null;
    }

    return obj.constructor.prototype;
  }

  function hasProperty(obj, property) {
    if (!obj) {
      return false;
    }

    if (Object.prototype.hasOwnProperty.call(obj, property)) {
      return true;
    }

    return hasProperty(getPrototype(obj), property);
  }

  ObjectContaining.prototype.asymmetricMatch = function(other) {
    if (typeof(this.sample) !== &#x27;object&#x27;) { throw new Error(&#x27;You must provide an object to objectContaining, not \&#x27;&#x27;+this.sample
+&#x27;\&#x27;.&#x27;); }

    for (var property in this.sample) {
      if (!hasProperty(other, property) ||
          !j$.matchersUtil.equals(this.sample[property], other[property])) {
        return false;
      }
    }

    return true;
  };

  ObjectContaining.prototype.jasmineToString = function() {
    return &#x27;&#x3c;jasmine.objectContaining(&#x27; + j$.pp(this.sample) + &#x27;)&#x3e;&#x27;;
  };

  return ObjectContaining;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.<span class="apidocCodeKeywordSpan">ObjectContaining</span>(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.Spec(j$);
j$.SpyRegistry = jRequire.SpyRegistry(j$);
j$.SpyStrategy = jRequire.SpyStrategy(j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.Order" id="apidoc.element.jasmine-core.jasmine.Order">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>Order
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Order = function () {
  function Order(options) {
    this.random = &#x27;random&#x27; in options ? options.random : true;
    var seed = this.seed = options.seed || generateSeed();
    this.sort = this.random ? randomOrder : naturalOrder;

    function naturalOrder(items) {
      return items;
    }

    function randomOrder(items) {
      var copy = items.slice();
      copy.sort(function(a, b) {
        return jenkinsHash(seed + a.id) - jenkinsHash(seed + b.id);
      });
      return copy;
    }

    function generateSeed() {
      return String(Math.random()).slice(-5);
    }

    // Bob Jenkins One-at-a-Time Hash algorithm is a non-cryptographic hash function
    // used to get a different output when the key changes slighly.
    // We use your return to sort the children randomly in a consistent way when
    // used in conjunction with a seed

    function jenkinsHash(key) {
      var hash, i;
      for(hash = i = 0; i &#x3c; key.length; ++i) {
        hash += key.charCodeAt(i);
        hash += (hash &#x3c;&#x3c; 10);
        hash ^= (hash &#x3e;&#x3e; 6);
      }
      hash += (hash &#x3c;&#x3c; 3);
      hash ^= (hash &#x3e;&#x3e; 11);
      hash += (hash &#x3c;&#x3c; 15);
      return hash;
    }

  }

  return Order;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  j$.SpyRegistry = jRequire.SpyRegistry(j$);
  j$.SpyStrategy = jRequire.SpyStrategy(j$);
  j$.StringMatching = jRequire.StringMatching(j$);
  j$.Suite = jRequire.Suite(j$);
  j$.Timer = jRequire.Timer();
  j$.TreeProcessor = jRequire.TreeProcessor();
  j$.version = jRequire.version();
  j$.Order = jRequire.<span class="apidocCodeKeywordSpan">Order</span>();

  j$.matchers = jRequire.requireMatchers(jRequire, j$);

  return j$;
};

return getJasmineRequire;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.QueueRunner" id="apidoc.element.jasmine-core.jasmine.QueueRunner">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>QueueRunner
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">QueueRunner = function (j$) {

  function once(fn) {
    var called = false;
    return function() {
      if (!called) {
        called = true;
        fn();
      }
      return null;
    };
  }

  function QueueRunner(attrs) {
    this.queueableFns = attrs.queueableFns || [];
    this.onComplete = attrs.onComplete || function() {};
    this.clearStack = attrs.clearStack || function(fn) {fn();};
    this.onException = attrs.onException || function() {};
    this.catchException = attrs.catchException || function() { return true; };
    this.userContext = attrs.userContext || {};
    this.timeout = attrs.timeout || {setTimeout: setTimeout, clearTimeout: clearTimeout};
    this.fail = attrs.fail || function() {};
  }

  QueueRunner.prototype.execute = function() {
    this.run(this.queueableFns, 0);
  };

  QueueRunner.prototype.run = function(queueableFns, recursiveIndex) {
    var length = queueableFns.length,
      self = this,
      iterativeIndex;


    for(iterativeIndex = recursiveIndex; iterativeIndex &#x3c; length; iterativeIndex++) {
      var queueableFn = queueableFns[iterativeIndex];
      if (queueableFn.fn.length &#x3e; 0) {
        attemptAsync(queueableFn);
        return;
      } else {
        attemptSync(queueableFn);
      }
    }

    var runnerDone = iterativeIndex &#x3e;= length;

    if (runnerDone) {
      this.clearStack(this.onComplete);
    }

    function attemptSync(queueableFn) {
      try {
        queueableFn.fn.call(self.userContext);
      } catch (e) {
        handleException(e, queueableFn);
      }
    }

    function attemptAsync(queueableFn) {
      var clearTimeout = function () {
          Function.prototype.apply.apply(self.timeout.clearTimeout, [j$.getGlobal(), [timeoutId]]);
        },
        next = once(function () {
          clearTimeout(timeoutId);
          self.run(queueableFns, iterativeIndex + 1);
        }),
        timeoutId;

      next.fail = function() {
        self.fail.apply(null, arguments);
        next();
      };

      if (queueableFn.timeout) {
        timeoutId = Function.prototype.apply.apply(self.timeout.setTimeout, [j$.getGlobal(), [function() {
          var error = new Error(&#x27;Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL
.&#x27;);
          onException(error);
          next();
        }, queueableFn.timeout()]]);
      }

      try {
        queueableFn.fn.call(self.userContext, next);
      } catch (e) {
        handleException(e, queueableFn);
        next();
      }
    }

    function onException(e) {
      self.onException(e);
    }

    function handleException(e, queueableFn) {
      onException(e);
      if (!self.catchException(e)) {
        //TODO: set a var when we catch an exception and
        //use a finally block to close the loop in a nice way..
        throw e;
      }
    }
  };

  return QueueRunner;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.<span class="apidocCodeKeywordSpan">QueueRunner</span>(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.Spec(j$);
j$.SpyRegistry = jRequire.SpyRegistry(j$);
j$.SpyStrategy = jRequire.SpyStrategy(j$);
j$.StringMatching = jRequire.StringMatching(j$);
j$.Suite = jRequire.Suite(j$);
j$.Timer = jRequire.Timer();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.ReportDispatcher" id="apidoc.element.jasmine-core.jasmine.ReportDispatcher">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>ReportDispatcher
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ReportDispatcher = function () {
  function ReportDispatcher(methods) {

    var dispatchedMethods = methods || [];

    for (var i = 0; i &#x3c; dispatchedMethods.length; i++) {
      var method = dispatchedMethods[i];
      this[method] = (function(m) {
        return function() {
          dispatch(m, arguments);
        };
      }(method));
    }

    var reporters = [];
    var fallbackReporter = null;

    this.addReporter = function(reporter) {
      reporters.push(reporter);
    };

    this.provideFallbackReporter = function(reporter) {
      fallbackReporter = reporter;
    };

    this.clearReporters = function() {
      reporters = [];
    };

    return this;

    function dispatch(method, args) {
      if (reporters.length === 0 &#x26;&#x26; fallbackReporter !== null) {
          reporters.push(fallbackReporter);
      }
      for (var i = 0; i &#x3c; reporters.length; i++) {
        var reporter = reporters[i];
        if (reporter[method]) {
          reporter[method].apply(reporter, args);
        }
      }
    }
  }

  return ReportDispatcher;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.<span class="apidocCodeKeywordSpan">ReportDispatcher</span>();
j$.Spec = jRequire.Spec(j$);
j$.SpyRegistry = jRequire.SpyRegistry(j$);
j$.SpyStrategy = jRequire.SpyStrategy(j$);
j$.StringMatching = jRequire.StringMatching(j$);
j$.Suite = jRequire.Suite(j$);
j$.Timer = jRequire.Timer();
j$.TreeProcessor = jRequire.TreeProcessor();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.Spec" id="apidoc.element.jasmine-core.jasmine.Spec">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>Spec
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Spec = function (j$) {
  function Spec(attrs) {
    this.expectationFactory = attrs.expectationFactory;
    this.resultCallback = attrs.resultCallback || function() {};
    this.id = attrs.id;
    this.description = attrs.description || &#x27;&#x27;;
    this.queueableFn = attrs.queueableFn;
    this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };
    this.userContext = attrs.userContext || function() { return {}; };
    this.onStart = attrs.onStart || function() {};
    this.getSpecName = attrs.getSpecName || function() { return &#x27;&#x27;; };
    this.expectationResultFactory = attrs.expectationResultFactory || function() { };
    this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};
    this.catchingExceptions = attrs.catchingExceptions || function() { return true; };
    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;

    if (!this.queueableFn.fn) {
      this.pend();
    }

    this.result = {
      id: this.id,
      description: this.description,
      fullName: this.getFullName(),
      failedExpectations: [],
      passedExpectations: [],
      pendingReason: &#x27;&#x27;
    };
  }

  Spec.prototype.addExpectationResult = function(passed, data, isError) {
    var expectationResult = this.expectationResultFactory(data);
    if (passed) {
      this.result.passedExpectations.push(expectationResult);
    } else {
      this.result.failedExpectations.push(expectationResult);

      if (this.throwOnExpectationFailure &#x26;&#x26; !isError) {
        throw new j$.errors.ExpectationFailed();
      }
    }
  };

  Spec.prototype.expect = function(actual) {
    return this.expectationFactory(actual, this);
  };

  Spec.prototype.execute = function(onComplete, enabled) {
    var self = this;

    this.onStart(this);

    if (!this.isExecutable() || this.markedPending || enabled === false) {
      complete(enabled);
      return;
    }

    var fns = this.beforeAndAfterFns();
    var allFns = fns.befores.concat(this.queueableFn).concat(fns.afters);

    this.queueRunnerFactory({
      queueableFns: allFns,
      onException: function() { self.onException.apply(self, arguments); },
      onComplete: complete,
      userContext: this.userContext()
    });

    function complete(enabledAgain) {
      self.result.status = self.status(enabledAgain);
      self.resultCallback(self.result);

      if (onComplete) {
        onComplete();
      }
    }
  };

  Spec.prototype.onException = function onException(e) {
    if (Spec.isPendingSpecException(e)) {
      this.pend(extractCustomPendingMessage(e));
      return;
    }

    if (e instanceof j$.errors.ExpectationFailed) {
      return;
    }

    this.addExpectationResult(false, {
      matcherName: &#x27;&#x27;,
      passed: false,
      expected: &#x27;&#x27;,
      actual: &#x27;&#x27;,
      error: e
    }, true);
  };

  Spec.prototype.disable = function() {
    this.disabled = true;
  };

  Spec.prototype.pend = function(message) {
    this.markedPending = true;
    if (message) {
      this.result.pendingReason = message;
    }
  };

  Spec.prototype.getResult = function() {
    this.result.status = this.status();
    return this.result;
  };

  Spec.prototype.status = function(enabled) {
    if (this.disabled || enabled === false) {
      return &#x27;disabled&#x27;;
    }

    if (this.markedPending) {
      return &#x27;pending&#x27;;
    }

    if (this.result.failedExpectations.length &#x3e; 0) {
      return &#x27;failed&#x27;;
    } else {
      return &#x27;passed&#x27;;
    }
  };

  Spec.prototype.isExecutable = function() {
    return !this.disabled;
  };

  Spec.prototype.getFullName = function() {
    return this.getSpecName(this);
  };

  var extractCustomPendingMessage = function(e) {
    var fullMessage = e.toString(),
        boilerplateStart = fullMessage.indexOf(Spec.pendingSpecExceptionMessage),
        boilerplateEnd = boilerplateStart + Spec.pendingSpecExceptionMessage.length;

    return fullMessage.substr(boilerplateEnd);
  };

  Spec.pendingSpecExceptionMessage = &#x27;=&#x3e; marked Pending&#x27;;

  Spec.isPendingSpecException = function(e) {
    return !!(e &#x26;&#x26; e.toString &#x26;&#x26; e.toString().inde ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.<span class="apidocCodeKeywordSpan">Spec</span>(j$);
j$.SpyRegistry = jRequire.SpyRegistry(j$);
j$.SpyStrategy = jRequire.SpyStrategy(j$);
j$.StringMatching = jRequire.StringMatching(j$);
j$.Suite = jRequire.Suite(j$);
j$.Timer = jRequire.Timer();
j$.TreeProcessor = jRequire.TreeProcessor();
j$.version = jRequire.version();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.SpyRegistry" id="apidoc.element.jasmine-core.jasmine.SpyRegistry">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>SpyRegistry
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SpyRegistry = function (j$) {

  var getErrorMsg = j$.formatErrorMsg(&#x27;&#x3c;spyOn&#x3e;&#x27;, &#x27;spyOn(&#x3c;object&#x3e;, &#x3c;methodName&#x3e;)&#x27;);

  function SpyRegistry(options) {
    options = options || {};
    var currentSpies = options.currentSpies || function() { return []; };

    this.allowRespy = function(allow){
      this.respy = allow;
    };

    this.spyOn = function(obj, methodName) {

      if (j$.util.isUndefined(obj)) {
        throw new Error(getErrorMsg(&#x27;could not find an object to spy upon for &#x27; + methodName + &#x27;()&#x27;));
      }

      if (j$.util.isUndefined(methodName)) {
        throw new Error(getErrorMsg(&#x27;No method name supplied&#x27;));
      }

      if (j$.util.isUndefined(obj[methodName])) {
        throw new Error(getErrorMsg(methodName + &#x27;() method does not exist&#x27;));
      }

      if (obj[methodName] &#x26;&#x26; j$.isSpy(obj[methodName])  ) {
        if ( !!this.respy ){
          return obj[methodName];
        }else {
          throw new Error(getErrorMsg(methodName + &#x27; has already been spied upon&#x27;));
        }
      }

      var descriptor;
      try {
        descriptor = Object.getOwnPropertyDescriptor(obj, methodName);
      } catch(e) {
        // IE 8 doesn&#x27;t support `definePropery` on non-DOM nodes
      }

      if (descriptor &#x26;&#x26; !(descriptor.writable || descriptor.set)) {
        throw new Error(getErrorMsg(methodName + &#x27; is not declared writable or has no setter&#x27;));
      }

      var originalMethod = obj[methodName],
        spiedMethod = j$.createSpy(methodName, originalMethod),
        restoreStrategy;

      if (Object.prototype.hasOwnProperty.call(obj, methodName)) {
        restoreStrategy = function() {
          obj[methodName] = originalMethod;
        };
      } else {
        restoreStrategy = function() {
          if (!delete obj[methodName]) {
            obj[methodName] = originalMethod;
          }
        };
      }

      currentSpies().push({
        restoreObjectToOriginalState: restoreStrategy
      });

      obj[methodName] = spiedMethod;

      return spiedMethod;
    };

    this.clearSpies = function() {
      var spies = currentSpies();
      for (var i = spies.length - 1; i &#x3e;= 0; i--) {
        var spyEntry = spies[i];
        spyEntry.restoreObjectToOriginalState();
      }
    };
  }

  return SpyRegistry;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.Spec(j$);
j$.SpyRegistry = jRequire.<span class="apidocCodeKeywordSpan">SpyRegistry</span>(j$);
j$.SpyStrategy = jRequire.SpyStrategy(j$);
j$.StringMatching = jRequire.StringMatching(j$);
j$.Suite = jRequire.Suite(j$);
j$.Timer = jRequire.Timer();
j$.TreeProcessor = jRequire.TreeProcessor();
j$.version = jRequire.version();
j$.Order = jRequire.Order();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.SpyStrategy" id="apidoc.element.jasmine-core.jasmine.SpyStrategy">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>SpyStrategy
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SpyStrategy = function (j$) {

  function SpyStrategy(options) {
    options = options || {};

    var identity = options.name || &#x27;unknown&#x27;,
        originalFn = options.fn || function() {},
        getSpy = options.getSpy || function() {},
        plan = function() {};

    this.identity = function() {
      return identity;
    };

    this.exec = function() {
      return plan.apply(this, arguments);
    };

    this.callThrough = function() {
      plan = originalFn;
      return getSpy();
    };

    this.returnValue = function(value) {
      plan = function() {
        return value;
      };
      return getSpy();
    };

    this.returnValues = function() {
      var values = Array.prototype.slice.call(arguments);
      plan = function () {
        return values.shift();
      };
      return getSpy();
    };

    this.throwError = function(something) {
      var error = (something instanceof Error) ? something : new Error(something);
      plan = function() {
        throw error;
      };
      return getSpy();
    };

    this.callFake = function(fn) {
      if(!j$.isFunction_(fn)) {
        throw new Error(&#x27;Argument passed to callFake should be a function, got &#x27; + fn);
      }
      plan = fn;
      return getSpy();
    };

    this.stub = function(fn) {
      plan = function() {};
      return getSpy();
    };
  }

  return SpyStrategy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.Spec(j$);
j$.SpyRegistry = jRequire.SpyRegistry(j$);
j$.SpyStrategy = jRequire.<span class="apidocCodeKeywordSpan">SpyStrategy</span>(j$);
j$.StringMatching = jRequire.StringMatching(j$);
j$.Suite = jRequire.Suite(j$);
j$.Timer = jRequire.Timer();
j$.TreeProcessor = jRequire.TreeProcessor();
j$.version = jRequire.version();
j$.Order = jRequire.Order();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.StringMatching" id="apidoc.element.jasmine-core.jasmine.StringMatching">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>StringMatching
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">StringMatching = function (j$) {

  function StringMatching(expected) {
    if (!j$.isString_(expected) &#x26;&#x26; !j$.isA_(&#x27;RegExp&#x27;, expected)) {
      throw new Error(&#x27;Expected is not a String or a RegExp&#x27;);
    }

    this.regexp = new RegExp(expected);
  }

  StringMatching.prototype.asymmetricMatch = function(other) {
    return this.regexp.test(other);
  };

  StringMatching.prototype.jasmineToString = function() {
    return &#x27;&#x3c;jasmine.stringMatching(&#x27; + this.regexp + &#x27;)&#x3e;&#x27;;
  };

  return StringMatching;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.Spec(j$);
j$.SpyRegistry = jRequire.SpyRegistry(j$);
j$.SpyStrategy = jRequire.SpyStrategy(j$);
j$.StringMatching = jRequire.<span class="apidocCodeKeywordSpan">StringMatching</span>(j$);
j$.Suite = jRequire.Suite(j$);
j$.Timer = jRequire.Timer();
j$.TreeProcessor = jRequire.TreeProcessor();
j$.version = jRequire.version();
j$.Order = jRequire.Order();

j$.matchers = jRequire.requireMatchers(jRequire, j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.Suite" id="apidoc.element.jasmine-core.jasmine.Suite">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>Suite
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Suite = function (j$) {
  function Suite(attrs) {
    this.env = attrs.env;
    this.id = attrs.id;
    this.parentSuite = attrs.parentSuite;
    this.description = attrs.description;
    this.expectationFactory = attrs.expectationFactory;
    this.expectationResultFactory = attrs.expectationResultFactory;
    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;

    this.beforeFns = [];
    this.afterFns = [];
    this.beforeAllFns = [];
    this.afterAllFns = [];
    this.disabled = false;

    this.children = [];

    this.result = {
      id: this.id,
      description: this.description,
      fullName: this.getFullName(),
      failedExpectations: []
    };
  }

  Suite.prototype.expect = function(actual) {
    return this.expectationFactory(actual, this);
  };

  Suite.prototype.getFullName = function() {
    var fullName = [];
    for (var parentSuite = this; parentSuite; parentSuite = parentSuite.parentSuite) {
      if (parentSuite.parentSuite) {
        fullName.unshift(parentSuite.description);
      }
    }
    return fullName.join(&#x27; &#x27;);
  };

  Suite.prototype.disable = function() {
    this.disabled = true;
  };

  Suite.prototype.pend = function(message) {
    this.markedPending = true;
  };

  Suite.prototype.beforeEach = function(fn) {
    this.beforeFns.unshift(fn);
  };

  Suite.prototype.beforeAll = function(fn) {
    this.beforeAllFns.push(fn);
  };

  Suite.prototype.afterEach = function(fn) {
    this.afterFns.unshift(fn);
  };

  Suite.prototype.afterAll = function(fn) {
    this.afterAllFns.push(fn);
  };

  Suite.prototype.addChild = function(child) {
    this.children.push(child);
  };

  Suite.prototype.status = function() {
    if (this.disabled) {
      return &#x27;disabled&#x27;;
    }

    if (this.markedPending) {
      return &#x27;pending&#x27;;
    }

    if (this.result.failedExpectations.length &#x3e; 0) {
      return &#x27;failed&#x27;;
    } else {
      return &#x27;finished&#x27;;
    }
  };

  Suite.prototype.isExecutable = function() {
    return !this.disabled;
  };

  Suite.prototype.canBeReentered = function() {
    return this.beforeAllFns.length === 0 &#x26;&#x26; this.afterAllFns.length === 0;
  };

  Suite.prototype.getResult = function() {
    this.result.status = this.status();
    return this.result;
  };

  Suite.prototype.sharedUserContext = function() {
    if (!this.sharedContext) {
      this.sharedContext = this.parentSuite ? clone(this.parentSuite.sharedUserContext()) : {};
    }

    return this.sharedContext;
  };

  Suite.prototype.clonedSharedUserContext = function() {
    return clone(this.sharedUserContext());
  };

  Suite.prototype.onException = function() {
    if (arguments[0] instanceof j$.errors.ExpectationFailed) {
      return;
    }

    if(isAfterAll(this.children)) {
      var data = {
        matcherName: &#x27;&#x27;,
        passed: false,
        expected: &#x27;&#x27;,
        actual: &#x27;&#x27;,
        error: arguments[0]
      };
      this.result.failedExpectations.push(this.expectationResultFactory(data));
    } else {
      for (var i = 0; i &#x3c; this.children.length; i++) {
        var child = this.children[i];
        child.onException.apply(child, arguments);
      }
    }
  };

  Suite.prototype.addExpectationResult = function () {
    if(isAfterAll(this.children) &#x26;&#x26; isFailure(arguments)){
      var data = arguments[1];
      this.result.failedExpectations.push(this.expectationResultFactory(data));
      if(this.throwOnExpectationFailure) {
        throw new j$.errors.ExpectationFailed();
      }
    } else {
      for (var i = 0; i &#x3c; this.children.length; i++) {
        var child = this.children[i];
        try {
          child.addExpectationResult.apply(child, arguments);
        } catch(e) {
          // keep going
        }
      }
    }
  };

  function isAfterAll(children) {
    return children &#x26;&#x26; children[0].result.status;
  }

  function isFailure(args) {
    return !args[0];
  }

  function clone(obj) {
    var clonedObj = {};
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        clonedObj[prop] = obj[prop];
      }
    }

    return clonedObj;
  }

  return Suite;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.Spec(j$);
j$.SpyRegistry = jRequire.SpyRegistry(j$);
j$.SpyStrategy = jRequire.SpyStrategy(j$);
j$.StringMatching = jRequire.StringMatching(j$);
j$.Suite = jRequire.<span class="apidocCodeKeywordSpan">Suite</span>(j$);
j$.Timer = jRequire.Timer();
j$.TreeProcessor = jRequire.TreeProcessor();
j$.version = jRequire.version();
j$.Order = jRequire.Order();

j$.matchers = jRequire.requireMatchers(jRequire, j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.Timer" id="apidoc.element.jasmine-core.jasmine.Timer">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>Timer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Timer = function () {
  var defaultNow = (function(Date) {
    return function() { return new Date().getTime(); };
  })(Date);

  function Timer(options) {
    options = options || {};

    var now = options.now || defaultNow,
      startTime;

    this.start = function() {
      startTime = now();
    };

    this.elapsed = function() {
      return now() - startTime;
    };
  }

  return Timer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.Spec(j$);
j$.SpyRegistry = jRequire.SpyRegistry(j$);
j$.SpyStrategy = jRequire.SpyStrategy(j$);
j$.StringMatching = jRequire.StringMatching(j$);
j$.Suite = jRequire.Suite(j$);
j$.Timer = jRequire.<span class="apidocCodeKeywordSpan">Timer</span>();
j$.TreeProcessor = jRequire.TreeProcessor();
j$.version = jRequire.version();
j$.Order = jRequire.Order();

j$.matchers = jRequire.requireMatchers(jRequire, j$);

return j$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.TreeProcessor" id="apidoc.element.jasmine-core.jasmine.TreeProcessor">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>TreeProcessor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TreeProcessor = function () {
  function TreeProcessor(attrs) {
    var tree = attrs.tree,
        runnableIds = attrs.runnableIds,
        queueRunnerFactory = attrs.queueRunnerFactory,
        nodeStart = attrs.nodeStart || function() {},
        nodeComplete = attrs.nodeComplete || function() {},
        orderChildren = attrs.orderChildren || function(node) { return node.children; },
        stats = { valid: true },
        processed = false,
        defaultMin = Infinity,
        defaultMax = 1 - Infinity;

    this.processTree = function() {
      processNode(tree, false);
      processed = true;
      return stats;
    };

    this.execute = function(done) {
      if (!processed) {
        this.processTree();
      }

      if (!stats.valid) {
        throw &#x27;invalid order&#x27;;
      }

      var childFns = wrapChildren(tree, 0);

      queueRunnerFactory({
        queueableFns: childFns,
        userContext: tree.sharedUserContext(),
        onException: function() {
          tree.onException.apply(tree, arguments);
        },
        onComplete: done
      });
    };

    function runnableIndex(id) {
      for (var i = 0; i &#x3c; runnableIds.length; i++) {
        if (runnableIds[i] === id) {
          return i;
        }
      }
    }

    function processNode(node, parentEnabled) {
      var executableIndex = runnableIndex(node.id);

      if (executableIndex !== undefined) {
        parentEnabled = true;
      }

      parentEnabled = parentEnabled &#x26;&#x26; node.isExecutable();

      if (!node.children) {
        stats[node.id] = {
          executable: parentEnabled &#x26;&#x26; node.isExecutable(),
          segments: [{
            index: 0,
            owner: node,
            nodes: [node],
            min: startingMin(executableIndex),
            max: startingMax(executableIndex)
          }]
        };
      } else {
        var hasExecutableChild = false;

        var orderedChildren = orderChildren(node);

        for (var i = 0; i &#x3c; orderedChildren.length; i++) {
          var child = orderedChildren[i];

          processNode(child, parentEnabled);

          if (!stats.valid) {
            return;
          }

          var childStats = stats[child.id];

          hasExecutableChild = hasExecutableChild || childStats.executable;
        }

        stats[node.id] = {
          executable: hasExecutableChild
        };

        segmentChildren(node, orderedChildren, stats[node.id], executableIndex);

        if (!node.canBeReentered() &#x26;&#x26; stats[node.id].segments.length &#x3e; 1) {
          stats = { valid: false };
        }
      }
    }

    function startingMin(executableIndex) {
      return executableIndex === undefined ? defaultMin : executableIndex;
    }

    function startingMax(executableIndex) {
      return executableIndex === undefined ? defaultMax : executableIndex;
    }

    function segmentChildren(node, orderedChildren, nodeStats, executableIndex) {
      var currentSegment = { index: 0, owner: node, nodes: [], min: startingMin(executableIndex), max: startingMax(executableIndex
) },
          result = [currentSegment],
          lastMax = defaultMax,
          orderedChildSegments = orderChildSegments(orderedChildren);

      function isSegmentBoundary(minIndex) {
        return lastMax !== defaultMax &#x26;&#x26; minIndex !== defaultMin &#x26;&#x26; lastMax &#x3c; minIndex - 1;
      }

      for (var i = 0; i &#x3c; orderedChildSegments.length; i++) {
        var childSegment = orderedChildSegments[i],
          maxIndex = childSegment.max,
          minIndex = childSegment.min;

        if (isSegmentBoundary(minIndex)) {
          currentSegment = {index: result.length, owner: node, nodes: [], min: defaultMin, max: defaultMax};
          result.push(currentSegment);
        }

        currentSegment.nodes.push(childSegment);
        currentSegment.min = Math.min(currentSegment.min, minIndex);
        currentSegment.max = Math.max(currentSegment.max, maxIndex);
        lastMax = maxIndex;
      }

      nodeStats.segments = result;
    }

    function orderChildSegments(children) {
      var specifiedOrder = [],
          unspecifiedOrder = []; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  j$.ReportDispatcher = jRequire.ReportDispatcher();
  j$.Spec = jRequire.Spec(j$);
  j$.SpyRegistry = jRequire.SpyRegistry(j$);
  j$.SpyStrategy = jRequire.SpyStrategy(j$);
  j$.StringMatching = jRequire.StringMatching(j$);
  j$.Suite = jRequire.Suite(j$);
  j$.Timer = jRequire.Timer();
  j$.TreeProcessor = jRequire.<span class="apidocCodeKeywordSpan">TreeProcessor</span>();
  j$.version = jRequire.version();
  j$.Order = jRequire.Order();

  j$.matchers = jRequire.requireMatchers(jRequire, j$);

  return j$;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.base" id="apidoc.element.jasmine-core.jasmine.base">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>base
        <span class="apidocSignatureSpan">(j$, jasmineGlobal)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">base = function (j$, jasmineGlobal) {
  j$.unimplementedMethod_ = function() {
    throw new Error(&#x27;unimplemented method&#x27;);
  };

  j$.MAX_PRETTY_PRINT_DEPTH = 40;
  j$.MAX_PRETTY_PRINT_ARRAY_LENGTH = 100;
  j$.DEFAULT_TIMEOUT_INTERVAL = 5000;

  j$.getGlobal = function() {
    return jasmineGlobal;
  };

  j$.getEnv = function(options) {
    var env = j$.currentEnv_ = j$.currentEnv_ || new j$.Env(options);
    //jasmine. singletons in here (setTimeout blah blah).
    return env;
  };

  j$.isArray_ = function(value) {
    return j$.isA_(&#x27;Array&#x27;, value);
  };

  j$.isString_ = function(value) {
    return j$.isA_(&#x27;String&#x27;, value);
  };

  j$.isNumber_ = function(value) {
    return j$.isA_(&#x27;Number&#x27;, value);
  };

  j$.isFunction_ = function(value) {
    return j$.isA_(&#x27;Function&#x27;, value);
  };

  j$.isA_ = function(typeName, value) {
    return Object.prototype.toString.apply(value) === &#x27;[object &#x27; + typeName + &#x27;]&#x27;;
  };

  j$.isDomNode = function(obj) {
    return obj.nodeType &#x3e; 0;
  };

  j$.fnNameFor = function(func) {
    if (func.name) {
      return func.name;
    }

    var matches = func.toString().match(/^\s*function\s*(\w*)\s*\(/);
    return matches ? matches[1] : &#x27;&#x3c;anonymous&#x3e;&#x27;;
  };

  j$.any = function(clazz) {
    return new j$.Any(clazz);
  };

  j$.anything = function() {
    return new j$.Anything();
  };

  j$.objectContaining = function(sample) {
    return new j$.ObjectContaining(sample);
  };

  j$.stringMatching = function(expected) {
    return new j$.StringMatching(expected);
  };

  j$.arrayContaining = function(sample) {
    return new j$.ArrayContaining(sample);
  };

  j$.createSpy = function(name, originalFn) {

    var spyStrategy = new j$.SpyStrategy({
        name: name,
        fn: originalFn,
        getSpy: function() { return spy; }
      }),
      callTracker = new j$.CallTracker(),
      spy = function() {
        var callData = {
          object: this,
          args: Array.prototype.slice.apply(arguments)
        };

        callTracker.track(callData);
        var returnValue = spyStrategy.exec.apply(this, arguments);
        callData.returnValue = returnValue;

        return returnValue;
      };

    for (var prop in originalFn) {
      if (prop === &#x27;and&#x27; || prop === &#x27;calls&#x27;) {
        throw new Error(&#x27;Jasmine spies would overwrite the \&#x27;and\&#x27; and \&#x27;calls\&#x27; properties on the object being spied upon&#x27;);
      }

      spy[prop] = originalFn[prop];
    }

    spy.and = spyStrategy;
    spy.calls = callTracker;

    return spy;
  };

  j$.isSpy = function(putativeSpy) {
    if (!putativeSpy) {
      return false;
    }
    return putativeSpy.and instanceof j$.SpyStrategy &#x26;&#x26;
      putativeSpy.calls instanceof j$.CallTracker;
  };

  j$.createSpyObj = function(baseName, methodNames) {
    if (j$.isArray_(baseName) &#x26;&#x26; j$.util.isUndefined(methodNames)) {
      methodNames = baseName;
      baseName = &#x27;unknown&#x27;;
    }

    if (!j$.isArray_(methodNames) || methodNames.length === 0) {
      throw &#x27;createSpyObj requires a non-empty array of method names to create spies for&#x27;;
    }
    var obj = {};
    for (var i = 0; i &#x3c; methodNames.length; i++) {
      obj[methodNames[i]] = j$.createSpy(baseName + &#x27;.&#x27; + methodNames[i]);
    }
    return obj;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function getJasmineRequire() {
return jasmineRequire;
  }

  getJasmineRequire().core = function(jRequire) {
var j$ = {};

jRequire.<span class="apidocCodeKeywordSpan">base</span>(j$, jasmineGlobal);
j$.util = jRequire.util();
j$.errors = jRequire.errors();
j$.formatErrorMsg = jRequire.formatErrorMsg();
j$.Any = jRequire.Any(j$);
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.boot" id="apidoc.element.jasmine-core.jasmine.boot">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>boot
        <span class="apidocSignatureSpan">(jasmineRequire)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">boot = function (jasmineRequire) {
  var jasmine = jasmineRequire.core(jasmineRequire);

  var consoleFns = require(&#x27;../console/console.js&#x27;);
  consoleFns.console(consoleFns, jasmine);

  var env = jasmine.getEnv();

  var jasmineInterface = jasmineRequire.interface(jasmine, env);

  extend(global, jasmineInterface);

  function extend(destination, source) {
    for (var property in source) destination[property] = source[property];
    return destination;
  }

  return jasmine;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.buildExpectationResult" id="apidoc.element.jasmine-core.jasmine.buildExpectationResult">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>buildExpectationResult
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildExpectationResult = function () {
  function buildExpectationResult(options) {
    var messageFormatter = options.messageFormatter || function() {},
      stackFormatter = options.stackFormatter || function() {};

    var result = {
      matcherName: options.matcherName,
      message: message(),
      stack: stack(),
      passed: options.passed
    };

    if(!result.passed) {
      result.expected = options.expected;
      result.actual = options.actual;
    }

    return result;

    function message() {
      if (options.passed) {
        return &#x27;Passed.&#x27;;
      } else if (options.message) {
        return options.message;
      } else if (options.error) {
        return messageFormatter(options.error);
      }
      return &#x27;&#x27;;
    }

    function stack() {
      if (options.passed) {
        return &#x27;&#x27;;
      }

      var error = options.error;
      if (!error) {
        try {
          throw new Error(message());
        } catch (e) {
          error = e;
        }
      }
      return stackFormatter(error);
    }
  }

  return buildExpectationResult;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.<span class="apidocCodeKeywordSpan">buildExpectationResult</span>();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.core" id="apidoc.element.jasmine-core.jasmine.core">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>core
        <span class="apidocSignatureSpan">(jRequire)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">core = function (jRequire) {
  var j$ = {};

  jRequire.base(j$, jasmineGlobal);
  j$.util = jRequire.util();
  j$.errors = jRequire.errors();
  j$.formatErrorMsg = jRequire.formatErrorMsg();
  j$.Any = jRequire.Any(j$);
  j$.Anything = jRequire.Anything(j$);
  j$.CallTracker = jRequire.CallTracker(j$);
  j$.MockDate = jRequire.MockDate();
  j$.Clock = jRequire.Clock();
  j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
  j$.Env = jRequire.Env(j$);
  j$.ExceptionFormatter = jRequire.ExceptionFormatter();
  j$.Expectation = jRequire.Expectation();
  j$.buildExpectationResult = jRequire.buildExpectationResult();
  j$.JsApiReporter = jRequire.JsApiReporter();
  j$.matchersUtil = jRequire.matchersUtil(j$);
  j$.ObjectContaining = jRequire.ObjectContaining(j$);
  j$.ArrayContaining = jRequire.ArrayContaining(j$);
  j$.pp = jRequire.pp(j$);
  j$.QueueRunner = jRequire.QueueRunner(j$);
  j$.ReportDispatcher = jRequire.ReportDispatcher();
  j$.Spec = jRequire.Spec(j$);
  j$.SpyRegistry = jRequire.SpyRegistry(j$);
  j$.SpyStrategy = jRequire.SpyStrategy(j$);
  j$.StringMatching = jRequire.StringMatching(j$);
  j$.Suite = jRequire.Suite(j$);
  j$.Timer = jRequire.Timer();
  j$.TreeProcessor = jRequire.TreeProcessor();
  j$.version = jRequire.version();
  j$.Order = jRequire.Order();

  j$.matchers = jRequire.requireMatchers(jRequire, j$);

  return j$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
module.exports = function(jasmineRequire) {
var jasmine = jasmineRequire.<span class="apidocCodeKeywordSpan">core</span>(jasmineRequire);

var consoleFns = require(&#x27;../console/console.js&#x27;);
consoleFns.console(consoleFns, jasmine);

var env = jasmine.getEnv();

var jasmineInterface = jasmineRequire.interface(jasmine, env);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.errors" id="apidoc.element.jasmine-core.jasmine.errors">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>errors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">errors = function () {
  function ExpectationFailed() {}

  ExpectationFailed.prototype = new Error();
  ExpectationFailed.prototype.constructor = ExpectationFailed;

  return {
    ExpectationFailed: ExpectationFailed
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  getJasmineRequire().core = function(jRequire) {
var j$ = {};

jRequire.base(j$, jasmineGlobal);
j$.util = jRequire.util();
j$.errors = jRequire.<span class="apidocCodeKeywordSpan">errors</span>();
j$.formatErrorMsg = jRequire.formatErrorMsg();
j$.Any = jRequire.Any(j$);
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.formatErrorMsg" id="apidoc.element.jasmine-core.jasmine.formatErrorMsg">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>formatErrorMsg
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">formatErrorMsg = function () {
  function generateErrorMsg(domain, usage) {
    var usageDefinition = usage ? &#x27;\nUsage: &#x27; + usage : &#x27;&#x27;;

    return function errorMsg(msg) {
      return domain + &#x27; : &#x27; + msg + usageDefinition;
    };
  }

  return generateErrorMsg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  getJasmineRequire().core = function(jRequire) {
var j$ = {};

jRequire.base(j$, jasmineGlobal);
j$.util = jRequire.util();
j$.errors = jRequire.errors();
j$.formatErrorMsg = jRequire.<span class="apidocCodeKeywordSpan">formatErrorMsg</span>();
j$.Any = jRequire.Any(j$);
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.interface" id="apidoc.element.jasmine-core.jasmine.interface">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>interface
        <span class="apidocSignatureSpan">(jasmine, env)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interface = function (jasmine, env) {
  var jasmineInterface = {
    describe: function(description, specDefinitions) {
      return env.describe(description, specDefinitions);
    },

    xdescribe: function(description, specDefinitions) {
      return env.xdescribe(description, specDefinitions);
    },

    fdescribe: function(description, specDefinitions) {
      return env.fdescribe(description, specDefinitions);
    },

    it: function() {
      return env.it.apply(env, arguments);
    },

    xit: function() {
      return env.xit.apply(env, arguments);
    },

    fit: function() {
      return env.fit.apply(env, arguments);
    },

    beforeEach: function() {
      return env.beforeEach.apply(env, arguments);
    },

    afterEach: function() {
      return env.afterEach.apply(env, arguments);
    },

    beforeAll: function() {
      return env.beforeAll.apply(env, arguments);
    },

    afterAll: function() {
      return env.afterAll.apply(env, arguments);
    },

    expect: function(actual) {
      return env.expect(actual);
    },

    pending: function() {
      return env.pending.apply(env, arguments);
    },

    fail: function() {
      return env.fail.apply(env, arguments);
    },

    spyOn: function(obj, methodName) {
      return env.spyOn(obj, methodName);
    },

    jsApiReporter: new jasmine.JsApiReporter({
      timer: new jasmine.Timer()
    }),

    jasmine: jasmine
  };

  jasmine.addCustomEqualityTester = function(tester) {
    env.addCustomEqualityTester(tester);
  };

  jasmine.addMatchers = function(matchers) {
    return env.addMatchers(matchers);
  };

  jasmine.clock = function() {
    return env.clock;
  };

  return jasmineInterface;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var jasmine = jasmineRequire.core(jasmineRequire);

var consoleFns = require(&#x27;../console/console.js&#x27;);
consoleFns.console(consoleFns, jasmine);

var env = jasmine.getEnv();

var jasmineInterface = jasmineRequire.<span class="apidocCodeKeywordSpan">interface</span>(jasmine, env);

extend(global, jasmineInterface);

function extend(destination, source) {
  for (var property in source) destination[property] = source[property];
  return destination;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.matchersUtil" id="apidoc.element.jasmine-core.jasmine.matchersUtil">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>matchersUtil
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">matchersUtil = function (j$) {
  // TODO: what to do about jasmine.pp not being inject? move to JSON.stringify? gut PrettyPrinter?

  return {
    equals: function(a, b, customTesters) {
      customTesters = customTesters || [];

      return eq(a, b, [], [], customTesters);
    },

    contains: function(haystack, needle, customTesters) {
      customTesters = customTesters || [];

      if ((Object.prototype.toString.apply(haystack) === &#x27;[object Array]&#x27;) ||
        (!!haystack &#x26;&#x26; !haystack.indexOf))
      {
        for (var i = 0; i &#x3c; haystack.length; i++) {
          if (eq(haystack[i], needle, [], [], customTesters)) {
            return true;
          }
        }
        return false;
      }

      return !!haystack &#x26;&#x26; haystack.indexOf(needle) &#x3e;= 0;
    },

    buildFailureMessage: function() {
      var args = Array.prototype.slice.call(arguments, 0),
        matcherName = args[0],
        isNot = args[1],
        actual = args[2],
        expected = args.slice(3),
        englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return &#x27; &#x27; + s.toLowerCase(); });

      var message = &#x27;Expected &#x27; +
        j$.pp(actual) +
        (isNot ? &#x27; not &#x27; : &#x27; &#x27;) +
        englishyPredicate;

      if (expected.length &#x3e; 0) {
        for (var i = 0; i &#x3c; expected.length; i++) {
          if (i &#x3e; 0) {
            message += &#x27;,&#x27;;
          }
          message += &#x27; &#x27; + j$.pp(expected[i]);
        }
      }

      return message + &#x27;.&#x27;;
    }
  };

  function isAsymmetric(obj) {
    return obj &#x26;&#x26; j$.isA_(&#x27;Function&#x27;, obj.asymmetricMatch);
  }

  function asymmetricMatch(a, b) {
    var asymmetricA = isAsymmetric(a),
        asymmetricB = isAsymmetric(b);

    if (asymmetricA &#x26;&#x26; asymmetricB) {
      return undefined;
    }

    if (asymmetricA) {
      return a.asymmetricMatch(b);
    }

    if (asymmetricB) {
      return b.asymmetricMatch(a);
    }
  }

  // Equality function lovingly adapted from isEqual in
  //   [Underscore](http://underscorejs.org)
  function eq(a, b, aStack, bStack, customTesters) {
    var result = true;

    var asymmetricResult = asymmetricMatch(a, b);
    if (!j$.util.isUndefined(asymmetricResult)) {
      return asymmetricResult;
    }

    for (var i = 0; i &#x3c; customTesters.length; i++) {
      var customTesterResult = customTesters[i](a, b);
      if (!j$.util.isUndefined(customTesterResult)) {
        return customTesterResult;
      }
    }

    if (a instanceof Error &#x26;&#x26; b instanceof Error) {
      return a.message == b.message;
    }

    // Identical objects are equal. `0 === -0`, but they aren&#x27;t identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) { return a !== 0 || 1 / a == 1 / b; }
    // A strict comparison is necessary because `null == undefined`.
    if (a === null || b === null) { return a === b; }
    var className = Object.prototype.toString.call(a);
    if (className != Object.prototype.toString.call(b)) { return false; }
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case &#x27;[object String]&#x27;:
        // Primitives and their corresponding object wrappers are equivalent; thus, `&#x22;5&#x22;` is
        // equivalent to `new String(&#x22;5&#x22;)`.
        return a == String(b);
      case &#x27;[object Number]&#x27;:
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a === 0 ? 1 / a == 1 / b : a == +b);
      case &#x27;[object Date]&#x27;:
      case &#x27;[object Boolean]&#x27;:
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case &#x27;[object RegExp]&#x27;:
        return a.source == b.source &#x26;&#x26;
          a.global == b.global &#x26;&#x26;
          a.multiline == b.multiline &#x26;&#x26;
          a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != &#x27;object&#x27; || typeo ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.Clock = jRequire.Clock();
j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
j$.Env = jRequire.Env(j$);
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.<span class="apidocCodeKeywordSpan">matchersUtil</span>(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.pp(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.Spec(j$);
j$.SpyRegistry = jRequire.SpyRegistry(j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.pp" id="apidoc.element.jasmine-core.jasmine.pp">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>pp
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pp = function (j$) {

  function PrettyPrinter() {
    this.ppNestLevel_ = 0;
    this.seen = [];
  }

  PrettyPrinter.prototype.format = function(value) {
    this.ppNestLevel_++;
    try {
      if (j$.util.isUndefined(value)) {
        this.emitScalar(&#x27;undefined&#x27;);
      } else if (value === null) {
        this.emitScalar(&#x27;null&#x27;);
      } else if (value === 0 &#x26;&#x26; 1/value === -Infinity) {
        this.emitScalar(&#x27;-0&#x27;);
      } else if (value === j$.getGlobal()) {
        this.emitScalar(&#x27;&#x3c;global&#x3e;&#x27;);
      } else if (value.jasmineToString) {
        this.emitScalar(value.jasmineToString());
      } else if (typeof value === &#x27;string&#x27;) {
        this.emitString(value);
      } else if (j$.isSpy(value)) {
        this.emitScalar(&#x27;spy on &#x27; + value.and.identity());
      } else if (value instanceof RegExp) {
        this.emitScalar(value.toString());
      } else if (typeof value === &#x27;function&#x27;) {
        this.emitScalar(&#x27;Function&#x27;);
      } else if (typeof value.nodeType === &#x27;number&#x27;) {
        this.emitScalar(&#x27;HTMLNode&#x27;);
      } else if (value instanceof Date) {
        this.emitScalar(&#x27;Date(&#x27; + value + &#x27;)&#x27;);
      } else if (value.toString &#x26;&#x26; typeof value === &#x27;object&#x27; &#x26;&#x26; !(value instanceof Array) &#x26;&#x26; value.toString !== Object.prototype
.toString) {
        this.emitScalar(value.toString());
      } else if (j$.util.arrayContains(this.seen, value)) {
        this.emitScalar(&#x27;&#x3c;circular reference: &#x27; + (j$.isArray_(value) ? &#x27;Array&#x27; : &#x27;Object&#x27;) + &#x27;&#x3e;&#x27;);
      } else if (j$.isArray_(value) || j$.isA_(&#x27;Object&#x27;, value)) {
        this.seen.push(value);
        if (j$.isArray_(value)) {
          this.emitArray(value);
        } else {
          this.emitObject(value);
        }
        this.seen.pop();
      } else {
        this.emitScalar(value.toString());
      }
    } finally {
      this.ppNestLevel_--;
    }
  };

  PrettyPrinter.prototype.iterateObject = function(obj, fn) {
    for (var property in obj) {
      if (!Object.prototype.hasOwnProperty.call(obj, property)) { continue; }
      fn(property, obj.__lookupGetter__ ? (!j$.util.isUndefined(obj.__lookupGetter__(property)) &#x26;&#x26;
          obj.__lookupGetter__(property) !== null) : false);
    }
  };

  PrettyPrinter.prototype.emitArray = j$.unimplementedMethod_;
  PrettyPrinter.prototype.emitObject = j$.unimplementedMethod_;
  PrettyPrinter.prototype.emitScalar = j$.unimplementedMethod_;
  PrettyPrinter.prototype.emitString = j$.unimplementedMethod_;

  function StringPrettyPrinter() {
    PrettyPrinter.call(this);

    this.string = &#x27;&#x27;;
  }

  j$.util.inherit(StringPrettyPrinter, PrettyPrinter);

  StringPrettyPrinter.prototype.emitScalar = function(value) {
    this.append(value);
  };

  StringPrettyPrinter.prototype.emitString = function(value) {
    this.append(&#x27;\&#x27;&#x27; + value + &#x27;\&#x27;&#x27;);
  };

  StringPrettyPrinter.prototype.emitArray = function(array) {
    if (this.ppNestLevel_ &#x3e; j$.MAX_PRETTY_PRINT_DEPTH) {
      this.append(&#x27;Array&#x27;);
      return;
    }
    var length = Math.min(array.length, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    this.append(&#x27;[ &#x27;);
    for (var i = 0; i &#x3c; length; i++) {
      if (i &#x3e; 0) {
        this.append(&#x27;, &#x27;);
      }
      this.format(array[i]);
    }
    if(array.length &#x3e; length){
      this.append(&#x27;, ...&#x27;);
    }

    var self = this;
    var first = array.length === 0;
    this.iterateObject(array, function(property, isGetter) {
      if (property.match(/^\d+$/)) {
        return;
      }

      if (first) {
        first = false;
      } else {
        self.append(&#x27;, &#x27;);
      }

      self.formatProperty(array, property, isGetter);
    });

    this.append(&#x27; ]&#x27;);
  };

  StringPrettyPrinter.prototype.emitObject = function(obj) {
    var constructorName = obj.constructor ? j$.fnNameFor(obj.constructor) : &#x27;null&#x27;;
    this.append(constructorName);

    if (this.ppNestLevel_ &#x3e; j$.MAX_PRETTY_PRINT_DEPTH) {
      return;
    }

    var self = this;
    this.append(&#x27;({ &#x27;);
    var first = true;

    this.iterateObject(obj, function(property, isGetter) {
      if (first) {
        first = false;
      } else {
        self.append(&#x27;, &#x27;);
      }

      s ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
j$.ExceptionFormatter = jRequire.ExceptionFormatter();
j$.Expectation = jRequire.Expectation();
j$.buildExpectationResult = jRequire.buildExpectationResult();
j$.JsApiReporter = jRequire.JsApiReporter();
j$.matchersUtil = jRequire.matchersUtil(j$);
j$.ObjectContaining = jRequire.ObjectContaining(j$);
j$.ArrayContaining = jRequire.ArrayContaining(j$);
j$.pp = jRequire.<span class="apidocCodeKeywordSpan">pp</span>(j$);
j$.QueueRunner = jRequire.QueueRunner(j$);
j$.ReportDispatcher = jRequire.ReportDispatcher();
j$.Spec = jRequire.Spec(j$);
j$.SpyRegistry = jRequire.SpyRegistry(j$);
j$.SpyStrategy = jRequire.SpyStrategy(j$);
j$.StringMatching = jRequire.StringMatching(j$);
j$.Suite = jRequire.Suite(j$);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.requireMatchers" id="apidoc.element.jasmine-core.jasmine.requireMatchers">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>requireMatchers
        <span class="apidocSignatureSpan">(jRequire, j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">requireMatchers = function (jRequire, j$) {
  var availableMatchers = [
      &#x27;toBe&#x27;,
      &#x27;toBeCloseTo&#x27;,
      &#x27;toBeDefined&#x27;,
      &#x27;toBeFalsy&#x27;,
      &#x27;toBeGreaterThan&#x27;,
      &#x27;toBeGreaterThanOrEqual&#x27;,
      &#x27;toBeLessThanOrEqual&#x27;,
      &#x27;toBeLessThan&#x27;,
      &#x27;toBeNaN&#x27;,
      &#x27;toBeNull&#x27;,
      &#x27;toBeTruthy&#x27;,
      &#x27;toBeUndefined&#x27;,
      &#x27;toContain&#x27;,
      &#x27;toEqual&#x27;,
      &#x27;toHaveBeenCalled&#x27;,
      &#x27;toHaveBeenCalledWith&#x27;,
      &#x27;toHaveBeenCalledTimes&#x27;,
      &#x27;toMatch&#x27;,
      &#x27;toThrow&#x27;,
      &#x27;toThrowError&#x27;
    ],
    matchers = {};

  for (var i = 0; i &#x3c; availableMatchers.length; i++) {
    var name = availableMatchers[i];
    matchers[name] = jRequire[name](j$);
  }

  return matchers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    j$.StringMatching = jRequire.StringMatching(j$);
    j$.Suite = jRequire.Suite(j$);
    j$.Timer = jRequire.Timer();
    j$.TreeProcessor = jRequire.TreeProcessor();
    j$.version = jRequire.version();
    j$.Order = jRequire.Order();

    j$.matchers = jRequire.<span class="apidocCodeKeywordSpan">requireMatchers</span>(jRequire, j$);

    return j$;
  };

  return getJasmineRequire;
})(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.toBe" id="apidoc.element.jasmine-core.jasmine.toBe">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBe = function () {
  function toBe() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual === expected
        };
      }
    };
  }

  return toBe;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.toBeCloseTo" id="apidoc.element.jasmine-core.jasmine.toBeCloseTo">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBeCloseTo
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBeCloseTo = function () {

  function toBeCloseTo() {
    return {
      compare: function(actual, expected, precision) {
        if (precision !== 0) {
          precision = precision || 2;
        }

        return {
          pass: Math.abs(expected - actual) &#x3c; (Math.pow(10, -precision) / 2)
        };
      }
    };
  }

  return toBeCloseTo;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.toBeDefined" id="apidoc.element.jasmine-core.jasmine.toBeDefined">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBeDefined
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBeDefined = function () {
  function toBeDefined() {
    return {
      compare: function(actual) {
        return {
          pass: (void 0 !== actual)
        };
      }
    };
  }

  return toBeDefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.toBeFalsy" id="apidoc.element.jasmine-core.jasmine.toBeFalsy">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBeFalsy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBeFalsy = function () {
  function toBeFalsy() {
    return {
      compare: function(actual) {
        return {
          pass: !!!actual
        };
      }
    };
  }

  return toBeFalsy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.toBeGreaterThan" id="apidoc.element.jasmine-core.jasmine.toBeGreaterThan">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBeGreaterThan
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBeGreaterThan = function () {

  function toBeGreaterThan() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual &#x3e; expected
        };
      }
    };
  }

  return toBeGreaterThan;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.toBeGreaterThanOrEqual" id="apidoc.element.jasmine-core.jasmine.toBeGreaterThanOrEqual">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBeGreaterThanOrEqual
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBeGreaterThanOrEqual = function () {

  function toBeGreaterThanOrEqual() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual &#x3e;= expected
        };
      }
    };
  }

  return toBeGreaterThanOrEqual;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.toBeLessThan" id="apidoc.element.jasmine-core.jasmine.toBeLessThan">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBeLessThan
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBeLessThan = function () {
  function toBeLessThan() {
    return {

      compare: function(actual, expected) {
        return {
          pass: actual &#x3c; expected
        };
      }
    };
  }

  return toBeLessThan;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.toBeLessThanOrEqual" id="apidoc.element.jasmine-core.jasmine.toBeLessThanOrEqual">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBeLessThanOrEqual
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBeLessThanOrEqual = function () {
  function toBeLessThanOrEqual() {
    return {

      compare: function(actual, expected) {
        return {
          pass: actual &#x3c;= expected
        };
      }
    };
  }

  return toBeLessThanOrEqual;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.toBeNaN" id="apidoc.element.jasmine-core.jasmine.toBeNaN">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBeNaN
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBeNaN = function (j$) {

  function toBeNaN() {
    return {
      compare: function(actual) {
        var result = {
          pass: (actual !== actual)
        };

        if (result.pass) {
          result.message = &#x27;Expected actual not to be NaN.&#x27;;
        } else {
          result.message = function() { return &#x27;Expected &#x27; + j$.pp(actual) + &#x27; to be NaN.&#x27;; };
        }

        return result;
      }
    };
  }

  return toBeNaN;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.toBeNull" id="apidoc.element.jasmine-core.jasmine.toBeNull">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBeNull
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBeNull = function () {

  function toBeNull() {
    return {
      compare: function(actual) {
        return {
          pass: actual === null
        };
      }
    };
  }

  return toBeNull;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.toBeTruthy" id="apidoc.element.jasmine-core.jasmine.toBeTruthy">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBeTruthy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBeTruthy = function () {

  function toBeTruthy() {
    return {
      compare: function(actual) {
        return {
          pass: !!actual
        };
      }
    };
  }

  return toBeTruthy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.toBeUndefined" id="apidoc.element.jasmine-core.jasmine.toBeUndefined">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toBeUndefined
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBeUndefined = function () {

  function toBeUndefined() {
    return {
      compare: function(actual) {
        return {
          pass: void 0 === actual
        };
      }
    };
  }

  return toBeUndefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.toContain" id="apidoc.element.jasmine-core.jasmine.toContain">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toContain
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toContain = function () {
  function toContain(util, customEqualityTesters) {
    customEqualityTesters = customEqualityTesters || [];

    return {
      compare: function(actual, expected) {

        return {
          pass: util.contains(actual, expected, customEqualityTesters)
        };
      }
    };
  }

  return toContain;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.toEqual" id="apidoc.element.jasmine-core.jasmine.toEqual">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toEqual
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toEqual = function () {

  function toEqual(util, customEqualityTesters) {
    customEqualityTesters = customEqualityTesters || [];

    return {
      compare: function(actual, expected) {
        var result = {
          pass: false
        };

        result.pass = util.equals(actual, expected, customEqualityTesters);

        return result;
      }
    };
  }

  return toEqual;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.toHaveBeenCalled" id="apidoc.element.jasmine-core.jasmine.toHaveBeenCalled">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toHaveBeenCalled
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toHaveBeenCalled = function (j$) {

  var getErrorMsg = j$.formatErrorMsg(&#x27;&#x3c;toHaveBeenCalled&#x3e;&#x27;, &#x27;expect(&#x3c;spyObj&#x3e;).toHaveBeenCalled()&#x27;);

  function toHaveBeenCalled() {
    return {
      compare: function(actual) {
        var result = {};

        if (!j$.isSpy(actual)) {
          throw new Error(getErrorMsg(&#x27;Expected a spy, but got &#x27; + j$.pp(actual) + &#x27;.&#x27;));
        }

        if (arguments.length &#x3e; 1) {
          throw new Error(getErrorMsg(&#x27;Does not take arguments, use toHaveBeenCalledWith&#x27;));
        }

        result.pass = actual.calls.any();

        result.message = result.pass ?
          &#x27;Expected spy &#x27; + actual.and.identity() + &#x27; not to have been called.&#x27; :
          &#x27;Expected spy &#x27; + actual.and.identity() + &#x27; to have been called.&#x27;;

        return result;
      }
    };
  }

  return toHaveBeenCalled;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  return toEqual;
};

getJasmineRequireObj().toHaveBeenCalled = function(j$) {

  var getErrorMsg = j$.formatErrorMsg(&#x27;&#x3c;toHaveBeenCalled&#x3e;&#x27;, &#x27;expect(&#x3c;spyObj&#x3e;).<span class="apidocCodeKeywordSpan
">toHaveBeenCalled</span>()&#x27;);

  function toHaveBeenCalled() {
    return {
      compare: function(actual) {
var result = {};

if (!j$.isSpy(actual)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.toHaveBeenCalledTimes" id="apidoc.element.jasmine-core.jasmine.toHaveBeenCalledTimes">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toHaveBeenCalledTimes
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toHaveBeenCalledTimes = function (j$) {

  var getErrorMsg = j$.formatErrorMsg(&#x27;&#x3c;toHaveBeenCalledTimes&#x3e;&#x27;, &#x27;expect(&#x3c;spyObj&#x3e;).toHaveBeenCalledTimes(&#x3c;Number&#x3e;)&#x27;);

  function toHaveBeenCalledTimes() {
    return {
      compare: function(actual, expected) {
        if (!j$.isSpy(actual)) {
          throw new Error(getErrorMsg(&#x27;Expected a spy, but got &#x27; + j$.pp(actual) + &#x27;.&#x27;));
        }

        var args = Array.prototype.slice.call(arguments, 0),
          result = { pass: false };

        if (!j$.isNumber_(expected)){
          throw new Error(getErrorMsg(&#x27;The expected times failed is a required argument and must be a number.&#x27;));
        }

        actual = args[0];
        var calls = actual.calls.count();
        var timesMessage = expected === 1 ? &#x27;once&#x27; : expected + &#x27; times&#x27;;
        result.pass = calls === expected;
        result.message = result.pass ?
          &#x27;Expected spy &#x27; + actual.and.identity() + &#x27; not to have been called &#x27; + timesMessage + &#x27;. It was called &#x27; +  calls + &#x27;
times.&#x27; :
          &#x27;Expected spy &#x27; + actual.and.identity() + &#x27; to have been called &#x27; + timesMessage + &#x27;. It was called &#x27; +  calls + &#x27; times
.&#x27;;
        return result;
      }
    };
  }

  return toHaveBeenCalledTimes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

return toHaveBeenCalled;
};

getJasmineRequireObj().toHaveBeenCalledTimes = function(j$) {

var getErrorMsg = j$.formatErrorMsg(&#x27;&#x3c;toHaveBeenCalledTimes&#x3e;&#x27;, &#x27;expect(&#x3c;spyObj&#x3e;).<span class="
apidocCodeKeywordSpan">toHaveBeenCalledTimes</span>(&#x3c;Number&#x3e;)&#x27;);

function toHaveBeenCalledTimes() {
  return {
    compare: function(actual, expected) {
      if (!j$.isSpy(actual)) {
        throw new Error(getErrorMsg(&#x27;Expected a spy, but got &#x27; + j$.pp(actual) + &#x27;.&#x27;));
      }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.toHaveBeenCalledWith" id="apidoc.element.jasmine-core.jasmine.toHaveBeenCalledWith">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toHaveBeenCalledWith
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toHaveBeenCalledWith = function (j$) {

  var getErrorMsg = j$.formatErrorMsg(&#x27;&#x3c;toHaveBeenCalledWith&#x3e;&#x27;, &#x27;expect(&#x3c;spyObj&#x3e;).toHaveBeenCalledWith(...arguments)&#x27;);

  function toHaveBeenCalledWith(util, customEqualityTesters) {
    return {
      compare: function() {
        var args = Array.prototype.slice.call(arguments, 0),
          actual = args[0],
          expectedArgs = args.slice(1),
          result = { pass: false };

        if (!j$.isSpy(actual)) {
          throw new Error(getErrorMsg(&#x27;Expected a spy, but got &#x27; + j$.pp(actual) + &#x27;.&#x27;));
        }

        if (!actual.calls.any()) {
          result.message = function() { return &#x27;Expected spy &#x27; + actual.and.identity() + &#x27; to have been called with &#x27; + j$.pp(expectedArgs
) + &#x27; but it was never called.&#x27;; };
          return result;
        }

        if (util.contains(actual.calls.allArgs(), expectedArgs, customEqualityTesters)) {
          result.pass = true;
          result.message = function() { return &#x27;Expected spy &#x27; + actual.and.identity() + &#x27; not to have been called with &#x27; + j$.pp
(expectedArgs) + &#x27; but it was.&#x27;; };
        } else {
          result.message = function() { return &#x27;Expected spy &#x27; + actual.and.identity() + &#x27; to have been called with &#x27; + j$.pp(expectedArgs
) + &#x27; but actual calls were &#x27; + j$.pp(actual.calls.allArgs()).replace(/^\[ | \]$/g, &#x27;&#x27;) + &#x27;.&#x27;; };
        }

        return result;
      }
    };
  }

  return toHaveBeenCalledWith;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

return toHaveBeenCalledTimes;
};

getJasmineRequireObj().toHaveBeenCalledWith = function(j$) {

var getErrorMsg = j$.formatErrorMsg(&#x27;&#x3c;toHaveBeenCalledWith&#x3e;&#x27;, &#x27;expect(&#x3c;spyObj&#x3e;).<span class="
apidocCodeKeywordSpan">toHaveBeenCalledWith</span>(...arguments)&#x27;);

function toHaveBeenCalledWith(util, customEqualityTesters) {
  return {
    compare: function() {
      var args = Array.prototype.slice.call(arguments, 0),
        actual = args[0],
        expectedArgs = args.slice(1),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.toMatch" id="apidoc.element.jasmine-core.jasmine.toMatch">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toMatch
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toMatch = function (j$) {

  var getErrorMsg = j$.formatErrorMsg(&#x27;&#x3c;toMatch&#x3e;&#x27;, &#x27;expect(&#x3c;expectation&#x3e;).toMatch(&#x3c;string&#x3e; || &#x3c;regexp&#x3e;)&#x27;);

  function toMatch() {
    return {
      compare: function(actual, expected) {
        if (!j$.isString_(expected) &#x26;&#x26; !j$.isA_(&#x27;RegExp&#x27;, expected)) {
          throw new Error(getErrorMsg(&#x27;Expected is not a String or a RegExp&#x27;));
        }

        var regexp = new RegExp(expected);

        return {
          pass: regexp.test(actual)
        };
      }
    };
  }

  return toMatch;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

return toHaveBeenCalledWith;
};

getJasmineRequireObj().toMatch = function(j$) {

var getErrorMsg = j$.formatErrorMsg(&#x27;&#x3c;toMatch&#x3e;&#x27;, &#x27;expect(&#x3c;expectation&#x3e;).<span class="apidocCodeKeywordSpan
">toMatch</span>(&#x3c;string&#x3e; || &#x3c;regexp&#x3e;)&#x27;);

function toMatch() {
  return {
    compare: function(actual, expected) {
      if (!j$.isString_(expected) &#x26;&#x26; !j$.isA_(&#x27;RegExp&#x27;, expected)) {
        throw new Error(getErrorMsg(&#x27;Expected is not a String or a RegExp&#x27;));
      }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.toThrow" id="apidoc.element.jasmine-core.jasmine.toThrow">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toThrow
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toThrow = function (j$) {

  var getErrorMsg = j$.formatErrorMsg(&#x27;&#x3c;toThrow&#x3e;&#x27;, &#x27;expect(function() {&#x3c;expectation&#x3e;}).toThrow()&#x27;);

  function toThrow(util) {
    return {
      compare: function(actual, expected) {
        var result = { pass: false },
          threw = false,
          thrown;

        if (typeof actual != &#x27;function&#x27;) {
          throw new Error(getErrorMsg(&#x27;Actual is not a Function&#x27;));
        }

        try {
          actual();
        } catch (e) {
          threw = true;
          thrown = e;
        }

        if (!threw) {
          result.message = &#x27;Expected function to throw an exception.&#x27;;
          return result;
        }

        if (arguments.length == 1) {
          result.pass = true;
          result.message = function() { return &#x27;Expected function not to throw, but it threw &#x27; + j$.pp(thrown) + &#x27;.&#x27;; };

          return result;
        }

        if (util.equals(thrown, expected)) {
          result.pass = true;
          result.message = function() { return &#x27;Expected function not to throw &#x27; + j$.pp(expected) + &#x27;.&#x27;; };
        } else {
          result.message = function() { return &#x27;Expected function to throw &#x27; + j$.pp(expected) + &#x27;, but it threw &#x27; +  j$.pp(thrown
) + &#x27;.&#x27;; };
        }

        return result;
      }
    };
  }

  return toThrow;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

return toMatch;
};

getJasmineRequireObj().toThrow = function(j$) {

var getErrorMsg = j$.formatErrorMsg(&#x27;&#x3c;toThrow&#x3e;&#x27;, &#x27;expect(function() {&#x3c;expectation&#x3e;}).<span class
="apidocCodeKeywordSpan">toThrow</span>()&#x27;);

function toThrow(util) {
  return {
    compare: function(actual, expected) {
      var result = { pass: false },
        threw = false,
        thrown;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.toThrowError" id="apidoc.element.jasmine-core.jasmine.toThrowError">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>toThrowError
        <span class="apidocSignatureSpan">(j$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toThrowError = function (j$) {

  var getErrorMsg =  j$.formatErrorMsg(&#x27;&#x3c;toThrowError&#x3e;&#x27;, &#x27;expect(function() {&#x3c;expectation&#x3e;}).toThrowError(&#x3c;ErrorConstructor&#x3e;, &#x3c;message
&#x3e;)&#x27;);

  function toThrowError () {
    return {
      compare: function(actual) {
        var threw = false,
          pass = {pass: true},
          fail = {pass: false},
          thrown;

        if (typeof actual != &#x27;function&#x27;) {
          throw new Error(getErrorMsg(&#x27;Actual is not a Function&#x27;));
        }

        var errorMatcher = getMatcher.apply(null, arguments);

        try {
          actual();
        } catch (e) {
          threw = true;
          thrown = e;
        }

        if (!threw) {
          fail.message = &#x27;Expected function to throw an Error.&#x27;;
          return fail;
        }

        if (!(thrown instanceof Error)) {
          fail.message = function() { return &#x27;Expected function to throw an Error, but it threw &#x27; + j$.pp(thrown) + &#x27;.&#x27;; };
          return fail;
        }

        if (errorMatcher.hasNoSpecifics()) {
          pass.message = &#x27;Expected function not to throw an Error, but it threw &#x27; + j$.fnNameFor(thrown) + &#x27;.&#x27;;
          return pass;
        }

        if (errorMatcher.matches(thrown)) {
          pass.message = function() {
            return &#x27;Expected function not to throw &#x27; + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() + &#x27;.&#x27;;
          };
          return pass;
        } else {
          fail.message = function() {
            return &#x27;Expected function to throw &#x27; + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() +
              &#x27;, but it threw &#x27; + errorMatcher.thrownDescription(thrown) + &#x27;.&#x27;;
          };
          return fail;
        }
      }
    };

    function getMatcher() {
      var expected = null,
          errorType = null;

      if (arguments.length == 2) {
        expected = arguments[1];
        if (isAnErrorType(expected)) {
          errorType = expected;
          expected = null;
        }
      } else if (arguments.length &#x3e; 2) {
        errorType = arguments[1];
        expected = arguments[2];
        if (!isAnErrorType(errorType)) {
          throw new Error(getErrorMsg(&#x27;Expected error type is not an Error.&#x27;));
        }
      }

      if (expected &#x26;&#x26; !isStringOrRegExp(expected)) {
        if (errorType) {
          throw new Error(getErrorMsg(&#x27;Expected error message is not a string or RegExp.&#x27;));
        } else {
          throw new Error(getErrorMsg(&#x27;Expected is not an Error, string, or RegExp.&#x27;));
        }
      }

      function messageMatch(message) {
        if (typeof expected == &#x27;string&#x27;) {
          return expected == message;
        } else {
          return expected.test(message);
        }
      }

      return {
        errorTypeDescription: errorType ? j$.fnNameFor(errorType) : &#x27;an exception&#x27;,
        thrownDescription: function(thrown) {
          var thrownName = errorType ? j$.fnNameFor(thrown.constructor) : &#x27;an exception&#x27;,
              thrownMessage = &#x27;&#x27;;

          if (expected) {
            thrownMessage = &#x27; with message &#x27; + j$.pp(thrown.message);
          }

          return thrownName + thrownMessage;
        },
        messageDescription: function() {
          if (expected === null) {
            return &#x27;&#x27;;
          } else if (expected instanceof RegExp) {
            return &#x27; with a message matching &#x27; + j$.pp(expected);
          } else {
            return &#x27; with message &#x27; + j$.pp(expected);
          }
        },
        hasNoSpecifics: function() {
          return expected === null &#x26;&#x26; errorType === null;
        },
        matches: function(error) {
          return (errorType === null || error instanceof errorType) &#x26;&#x26;
            (expected === null || messageMatch(error.message));
        }
      };
    }

    function isStringOrRegExp(potential) {
      return potential instanceof RegExp || (typeof potential == &#x27;string&#x27;);
    }

    function isAnErrorType(type) {
      if (typeof type !== &#x27;function&#x27;) {
        return false;
      }

      var Surrogate = function() {};
      Surrogate.prototype = type.prototype;
      ret ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

return toThrow;
};

getJasmineRequireObj().toThrowError = function(j$) {

var getErrorMsg =  j$.formatErrorMsg(&#x27;&#x3c;toThrowError&#x3e;&#x27;, &#x27;expect(function() {&#x3c;expectation&#x3e;}).<span
 class="apidocCodeKeywordSpan">toThrowError</span>(&#x3c;ErrorConstructor&#x3e;, &#x3c;message&#x3e;)&#x27;);

function toThrowError () {
  return {
    compare: function(actual) {
      var threw = false,
        pass = {pass: true},
        fail = {pass: false},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.util" id="apidoc.element.jasmine-core.jasmine.util">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>util
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">util = function () {

  var util = {};

  util.inherit = function(childClass, parentClass) {
    var Subclass = function() {
    };
    Subclass.prototype = parentClass.prototype;
    childClass.prototype = new Subclass();
  };

  util.htmlEscape = function(str) {
    if (!str) {
      return str;
    }
    return str.replace(/&#x26;/g, &#x27;&#x26;amp;&#x27;)
      .replace(/&#x3c;/g, &#x27;&#x26;lt;&#x27;)
      .replace(/&#x3e;/g, &#x27;&#x26;gt;&#x27;);
  };

  util.argsToArray = function(args) {
    var arrayOfArgs = [];
    for (var i = 0; i &#x3c; args.length; i++) {
      arrayOfArgs.push(args[i]);
    }
    return arrayOfArgs;
  };

  util.isUndefined = function(obj) {
    return obj === void 0;
  };

  util.arrayContains = function(array, search) {
    var i = array.length;
    while (i--) {
      if (array[i] === search) {
        return true;
      }
    }
    return false;
  };

  util.clone = function(obj) {
    if (Object.prototype.toString.apply(obj) === &#x27;[object Array]&#x27;) {
      return obj.slice();
    }

    var cloned = {};
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        cloned[prop] = obj[prop];
      }
    }

    return cloned;
  };

  return util;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return jasmineRequire;
  }

  getJasmineRequire().core = function(jRequire) {
var j$ = {};

jRequire.base(j$, jasmineGlobal);
j$.util = jRequire.<span class="apidocCodeKeywordSpan">util</span>();
j$.errors = jRequire.errors();
j$.formatErrorMsg = jRequire.formatErrorMsg();
j$.Any = jRequire.Any(j$);
j$.Anything = jRequire.Anything(j$);
j$.CallTracker = jRequire.CallTracker(j$);
j$.MockDate = jRequire.MockDate();
j$.Clock = jRequire.Clock();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jasmine-core.jasmine.version" id="apidoc.element.jasmine-core.jasmine.version">
        function <span class="apidocSignatureSpan">jasmine-core.jasmine.</span>version
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">version = function () {
  return &#x27;2.5.2&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  j$.Spec = jRequire.Spec(j$);
  j$.SpyRegistry = jRequire.SpyRegistry(j$);
  j$.SpyStrategy = jRequire.SpyStrategy(j$);
  j$.StringMatching = jRequire.StringMatching(j$);
  j$.Suite = jRequire.Suite(j$);
  j$.Timer = jRequire.Timer();
  j$.TreeProcessor = jRequire.TreeProcessor();
  j$.version = jRequire.<span class="apidocCodeKeywordSpan">version</span>();
  j$.Order = jRequire.Order();

  j$.matchers = jRequire.requireMatchers(jRequire, j$);

  return j$;
};
...</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
